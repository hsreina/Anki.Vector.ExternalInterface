// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: anki_vector/messaging/external_interface.proto
// </auto-generated>
// Original file comments:
// Copyright (c) 2018 Anki, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the file LICENSE.txt or at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// External interface for robot <-> app and robot <-> sdk communication
//
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Anki.Vector.ExternalInterface {
  /// <summary>
  /// The grpc-defined connection between the SDK and Anki's Vector robot.
  /// </summary>
  public static partial class ExternalInterface
  {
    static readonly string __ServiceName = "Anki.Vector.external_interface.ExternalInterface";

    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ProtocolVersionRequest> __Marshaller_Anki_Vector_external_interface_ProtocolVersionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ProtocolVersionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ProtocolVersionResponse> __Marshaller_Anki_Vector_external_interface_ProtocolVersionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ProtocolVersionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SDKInitializationRequest> __Marshaller_Anki_Vector_external_interface_SDKInitializationRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SDKInitializationRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SDKInitializationResponse> __Marshaller_Anki_Vector_external_interface_SDKInitializationResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SDKInitializationResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveWheelsRequest> __Marshaller_Anki_Vector_external_interface_DriveWheelsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveWheelsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveWheelsResponse> __Marshaller_Anki_Vector_external_interface_DriveWheelsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveWheelsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest> __Marshaller_Anki_Vector_external_interface_PlayAnimationTriggerRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PlayAnimationResponse> __Marshaller_Anki_Vector_external_interface_PlayAnimationResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PlayAnimationResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PlayAnimationRequest> __Marshaller_Anki_Vector_external_interface_PlayAnimationRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PlayAnimationRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ListAnimationsRequest> __Marshaller_Anki_Vector_external_interface_ListAnimationsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ListAnimationsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ListAnimationsResponse> __Marshaller_Anki_Vector_external_interface_ListAnimationsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ListAnimationsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest> __Marshaller_Anki_Vector_external_interface_ListAnimationTriggersRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse> __Marshaller_Anki_Vector_external_interface_ListAnimationTriggersResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.MoveHeadRequest> __Marshaller_Anki_Vector_external_interface_MoveHeadRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.MoveHeadRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.MoveHeadResponse> __Marshaller_Anki_Vector_external_interface_MoveHeadResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.MoveHeadResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.MoveLiftRequest> __Marshaller_Anki_Vector_external_interface_MoveLiftRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.MoveLiftRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.MoveLiftResponse> __Marshaller_Anki_Vector_external_interface_MoveLiftResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.MoveLiftResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.StopAllMotorsRequest> __Marshaller_Anki_Vector_external_interface_StopAllMotorsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.StopAllMotorsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.StopAllMotorsResponse> __Marshaller_Anki_Vector_external_interface_StopAllMotorsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.StopAllMotorsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest> __Marshaller_Anki_Vector_external_interface_DisplayFaceImageRGBRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse> __Marshaller_Anki_Vector_external_interface_DisplayFaceImageRGBResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EventRequest> __Marshaller_Anki_Vector_external_interface_EventRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EventRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EventResponse> __Marshaller_Anki_Vector_external_interface_EventResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EventResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ExternalAudioStreamRequest> __Marshaller_Anki_Vector_external_interface_ExternalAudioStreamRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ExternalAudioStreamRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ExternalAudioStreamResponse> __Marshaller_Anki_Vector_external_interface_ExternalAudioStreamResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ExternalAudioStreamResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.BehaviorControlRequest> __Marshaller_Anki_Vector_external_interface_BehaviorControlRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.BehaviorControlRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.BehaviorControlResponse> __Marshaller_Anki_Vector_external_interface_BehaviorControlResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.BehaviorControlResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest> __Marshaller_Anki_Vector_external_interface_CancelFaceEnrollmentRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse> __Marshaller_Anki_Vector_external_interface_CancelFaceEnrollmentResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest> __Marshaller_Anki_Vector_external_interface_RequestEnrolledNamesRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse> __Marshaller_Anki_Vector_external_interface_RequestEnrolledNamesResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest> __Marshaller_Anki_Vector_external_interface_UpdateEnrolledFaceByIDRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse> __Marshaller_Anki_Vector_external_interface_UpdateEnrolledFaceByIDResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest> __Marshaller_Anki_Vector_external_interface_EraseEnrolledFaceByIDRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse> __Marshaller_Anki_Vector_external_interface_EraseEnrolledFaceByIDResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest> __Marshaller_Anki_Vector_external_interface_EraseAllEnrolledFacesRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse> __Marshaller_Anki_Vector_external_interface_EraseAllEnrolledFacesResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest> __Marshaller_Anki_Vector_external_interface_SetFaceToEnrollRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse> __Marshaller_Anki_Vector_external_interface_SetFaceToEnrollResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest> __Marshaller_Anki_Vector_external_interface_EnableMarkerDetectionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse> __Marshaller_Anki_Vector_external_interface_EnableMarkerDetectionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest> __Marshaller_Anki_Vector_external_interface_EnableFaceDetectionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse> __Marshaller_Anki_Vector_external_interface_EnableFaceDetectionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest> __Marshaller_Anki_Vector_external_interface_EnableMotionDetectionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse> __Marshaller_Anki_Vector_external_interface_EnableMotionDetectionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest> __Marshaller_Anki_Vector_external_interface_EnableMirrorModeRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse> __Marshaller_Anki_Vector_external_interface_EnableMirrorModeResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest> __Marshaller_Anki_Vector_external_interface_EnableImageStreamingRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse> __Marshaller_Anki_Vector_external_interface_EnableImageStreamingResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest> __Marshaller_Anki_Vector_external_interface_IsImageStreamingEnabledRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse> __Marshaller_Anki_Vector_external_interface_IsImageStreamingEnabledResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest> __Marshaller_Anki_Vector_external_interface_CancelActionByIdTagRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse> __Marshaller_Anki_Vector_external_interface_CancelActionByIdTagResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.GoToPoseRequest> __Marshaller_Anki_Vector_external_interface_GoToPoseRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.GoToPoseRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.GoToPoseResponse> __Marshaller_Anki_Vector_external_interface_GoToPoseResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.GoToPoseResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DockWithCubeRequest> __Marshaller_Anki_Vector_external_interface_DockWithCubeRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DockWithCubeRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DockWithCubeResponse> __Marshaller_Anki_Vector_external_interface_DockWithCubeResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DockWithCubeResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveOffChargerRequest> __Marshaller_Anki_Vector_external_interface_DriveOffChargerRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveOffChargerRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveOffChargerResponse> __Marshaller_Anki_Vector_external_interface_DriveOffChargerResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveOffChargerResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveOnChargerRequest> __Marshaller_Anki_Vector_external_interface_DriveOnChargerRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveOnChargerRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveOnChargerResponse> __Marshaller_Anki_Vector_external_interface_DriveOnChargerResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveOnChargerResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.FindFacesRequest> __Marshaller_Anki_Vector_external_interface_FindFacesRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.FindFacesRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.FindFacesResponse> __Marshaller_Anki_Vector_external_interface_FindFacesResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.FindFacesResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest> __Marshaller_Anki_Vector_external_interface_LookAroundInPlaceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse> __Marshaller_Anki_Vector_external_interface_LookAroundInPlaceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.RollBlockRequest> __Marshaller_Anki_Vector_external_interface_RollBlockRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.RollBlockRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.RollBlockResponse> __Marshaller_Anki_Vector_external_interface_RollBlockResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.RollBlockResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PhotosInfoRequest> __Marshaller_Anki_Vector_external_interface_PhotosInfoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PhotosInfoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PhotosInfoResponse> __Marshaller_Anki_Vector_external_interface_PhotosInfoResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PhotosInfoResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PhotoRequest> __Marshaller_Anki_Vector_external_interface_PhotoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PhotoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PhotoResponse> __Marshaller_Anki_Vector_external_interface_PhotoResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PhotoResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ThumbnailRequest> __Marshaller_Anki_Vector_external_interface_ThumbnailRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ThumbnailRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ThumbnailResponse> __Marshaller_Anki_Vector_external_interface_ThumbnailResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ThumbnailResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DeletePhotoRequest> __Marshaller_Anki_Vector_external_interface_DeletePhotoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DeletePhotoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DeletePhotoResponse> __Marshaller_Anki_Vector_external_interface_DeletePhotoResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DeletePhotoResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveStraightRequest> __Marshaller_Anki_Vector_external_interface_DriveStraightRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveStraightRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DriveStraightResponse> __Marshaller_Anki_Vector_external_interface_DriveStraightResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DriveStraightResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.TurnInPlaceRequest> __Marshaller_Anki_Vector_external_interface_TurnInPlaceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.TurnInPlaceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.TurnInPlaceResponse> __Marshaller_Anki_Vector_external_interface_TurnInPlaceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.TurnInPlaceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetHeadAngleRequest> __Marshaller_Anki_Vector_external_interface_SetHeadAngleRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetHeadAngleRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetHeadAngleResponse> __Marshaller_Anki_Vector_external_interface_SetHeadAngleResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetHeadAngleResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetLiftHeightRequest> __Marshaller_Anki_Vector_external_interface_SetLiftHeightRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetLiftHeightRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetLiftHeightResponse> __Marshaller_Anki_Vector_external_interface_SetLiftHeightResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetLiftHeightResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest> __Marshaller_Anki_Vector_external_interface_TurnTowardsFaceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse> __Marshaller_Anki_Vector_external_interface_TurnTowardsFaceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.GoToObjectRequest> __Marshaller_Anki_Vector_external_interface_GoToObjectRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.GoToObjectRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.GoToObjectResponse> __Marshaller_Anki_Vector_external_interface_GoToObjectResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.GoToObjectResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.RollObjectRequest> __Marshaller_Anki_Vector_external_interface_RollObjectRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.RollObjectRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.RollObjectResponse> __Marshaller_Anki_Vector_external_interface_RollObjectResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.RollObjectResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PopAWheelieRequest> __Marshaller_Anki_Vector_external_interface_PopAWheelieRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PopAWheelieRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PopAWheelieResponse> __Marshaller_Anki_Vector_external_interface_PopAWheelieResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PopAWheelieResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PickupObjectRequest> __Marshaller_Anki_Vector_external_interface_PickupObjectRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PickupObjectRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PickupObjectResponse> __Marshaller_Anki_Vector_external_interface_PickupObjectResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PickupObjectResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest> __Marshaller_Anki_Vector_external_interface_PlaceObjectOnGroundHereRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse> __Marshaller_Anki_Vector_external_interface_PlaceObjectOnGroundHereResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.MasterVolumeRequest> __Marshaller_Anki_Vector_external_interface_MasterVolumeRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.MasterVolumeRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.MasterVolumeResponse> __Marshaller_Anki_Vector_external_interface_MasterVolumeResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.MasterVolumeResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.UserAuthenticationRequest> __Marshaller_Anki_Vector_external_interface_UserAuthenticationRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.UserAuthenticationRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.UserAuthenticationResponse> __Marshaller_Anki_Vector_external_interface_UserAuthenticationResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.UserAuthenticationResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.BatteryStateRequest> __Marshaller_Anki_Vector_external_interface_BatteryStateRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.BatteryStateRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.BatteryStateResponse> __Marshaller_Anki_Vector_external_interface_BatteryStateResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.BatteryStateResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.VersionStateRequest> __Marshaller_Anki_Vector_external_interface_VersionStateRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.VersionStateRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.VersionStateResponse> __Marshaller_Anki_Vector_external_interface_VersionStateResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.VersionStateResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SayTextRequest> __Marshaller_Anki_Vector_external_interface_SayTextRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SayTextRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SayTextResponse> __Marshaller_Anki_Vector_external_interface_SayTextResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SayTextResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ConnectCubeRequest> __Marshaller_Anki_Vector_external_interface_ConnectCubeRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ConnectCubeRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ConnectCubeResponse> __Marshaller_Anki_Vector_external_interface_ConnectCubeResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ConnectCubeResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DisconnectCubeRequest> __Marshaller_Anki_Vector_external_interface_DisconnectCubeRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DisconnectCubeRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DisconnectCubeResponse> __Marshaller_Anki_Vector_external_interface_DisconnectCubeResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DisconnectCubeResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CubesAvailableRequest> __Marshaller_Anki_Vector_external_interface_CubesAvailableRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CubesAvailableRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CubesAvailableResponse> __Marshaller_Anki_Vector_external_interface_CubesAvailableResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CubesAvailableResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest> __Marshaller_Anki_Vector_external_interface_FlashCubeLightsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse> __Marshaller_Anki_Vector_external_interface_FlashCubeLightsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest> __Marshaller_Anki_Vector_external_interface_ForgetPreferredCubeRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse> __Marshaller_Anki_Vector_external_interface_ForgetPreferredCubeResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest> __Marshaller_Anki_Vector_external_interface_SetPreferredCubeRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse> __Marshaller_Anki_Vector_external_interface_SetPreferredCubeResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest> __Marshaller_Anki_Vector_external_interface_DeleteCustomObjectsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse> __Marshaller_Anki_Vector_external_interface_DeleteCustomObjectsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest> __Marshaller_Anki_Vector_external_interface_CreateFixedCustomObjectRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse> __Marshaller_Anki_Vector_external_interface_CreateFixedCustomObjectResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest> __Marshaller_Anki_Vector_external_interface_DefineCustomObjectRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse> __Marshaller_Anki_Vector_external_interface_DefineCustomObjectResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetCubeLightsRequest> __Marshaller_Anki_Vector_external_interface_SetCubeLightsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetCubeLightsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetCubeLightsResponse> __Marshaller_Anki_Vector_external_interface_SetCubeLightsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetCubeLightsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.AudioFeedRequest> __Marshaller_Anki_Vector_external_interface_AudioFeedRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.AudioFeedRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.AudioFeedResponse> __Marshaller_Anki_Vector_external_interface_AudioFeedResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.AudioFeedResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CameraFeedRequest> __Marshaller_Anki_Vector_external_interface_CameraFeedRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CameraFeedRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CameraFeedResponse> __Marshaller_Anki_Vector_external_interface_CameraFeedResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CameraFeedResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest> __Marshaller_Anki_Vector_external_interface_CaptureSingleImageRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse> __Marshaller_Anki_Vector_external_interface_CaptureSingleImageResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetEyeColorRequest> __Marshaller_Anki_Vector_external_interface_SetEyeColorRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetEyeColorRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.SetEyeColorResponse> __Marshaller_Anki_Vector_external_interface_SetEyeColorResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.SetEyeColorResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.NavMapFeedRequest> __Marshaller_Anki_Vector_external_interface_NavMapFeedRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.NavMapFeedRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Anki.Vector.ExternalInterface.NavMapFeedResponse> __Marshaller_Anki_Vector_external_interface_NavMapFeedResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Anki.Vector.ExternalInterface.NavMapFeedResponse.Parser.ParseFrom);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.ProtocolVersionRequest, global::Anki.Vector.ExternalInterface.ProtocolVersionResponse> __Method_ProtocolVersion = new grpc::Method<global::Anki.Vector.ExternalInterface.ProtocolVersionRequest, global::Anki.Vector.ExternalInterface.ProtocolVersionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ProtocolVersion",
        __Marshaller_Anki_Vector_external_interface_ProtocolVersionRequest,
        __Marshaller_Anki_Vector_external_interface_ProtocolVersionResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SDKInitializationRequest, global::Anki.Vector.ExternalInterface.SDKInitializationResponse> __Method_SDKInitialization = new grpc::Method<global::Anki.Vector.ExternalInterface.SDKInitializationRequest, global::Anki.Vector.ExternalInterface.SDKInitializationResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SDKInitialization",
        __Marshaller_Anki_Vector_external_interface_SDKInitializationRequest,
        __Marshaller_Anki_Vector_external_interface_SDKInitializationResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DriveWheelsRequest, global::Anki.Vector.ExternalInterface.DriveWheelsResponse> __Method_DriveWheels = new grpc::Method<global::Anki.Vector.ExternalInterface.DriveWheelsRequest, global::Anki.Vector.ExternalInterface.DriveWheelsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DriveWheels",
        __Marshaller_Anki_Vector_external_interface_DriveWheelsRequest,
        __Marshaller_Anki_Vector_external_interface_DriveWheelsResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest, global::Anki.Vector.ExternalInterface.PlayAnimationResponse> __Method_PlayAnimationTrigger = new grpc::Method<global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest, global::Anki.Vector.ExternalInterface.PlayAnimationResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PlayAnimationTrigger",
        __Marshaller_Anki_Vector_external_interface_PlayAnimationTriggerRequest,
        __Marshaller_Anki_Vector_external_interface_PlayAnimationResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.PlayAnimationRequest, global::Anki.Vector.ExternalInterface.PlayAnimationResponse> __Method_PlayAnimation = new grpc::Method<global::Anki.Vector.ExternalInterface.PlayAnimationRequest, global::Anki.Vector.ExternalInterface.PlayAnimationResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PlayAnimation",
        __Marshaller_Anki_Vector_external_interface_PlayAnimationRequest,
        __Marshaller_Anki_Vector_external_interface_PlayAnimationResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.ListAnimationsRequest, global::Anki.Vector.ExternalInterface.ListAnimationsResponse> __Method_ListAnimations = new grpc::Method<global::Anki.Vector.ExternalInterface.ListAnimationsRequest, global::Anki.Vector.ExternalInterface.ListAnimationsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListAnimations",
        __Marshaller_Anki_Vector_external_interface_ListAnimationsRequest,
        __Marshaller_Anki_Vector_external_interface_ListAnimationsResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest, global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse> __Method_ListAnimationTriggers = new grpc::Method<global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest, global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListAnimationTriggers",
        __Marshaller_Anki_Vector_external_interface_ListAnimationTriggersRequest,
        __Marshaller_Anki_Vector_external_interface_ListAnimationTriggersResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.MoveHeadRequest, global::Anki.Vector.ExternalInterface.MoveHeadResponse> __Method_MoveHead = new grpc::Method<global::Anki.Vector.ExternalInterface.MoveHeadRequest, global::Anki.Vector.ExternalInterface.MoveHeadResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "MoveHead",
        __Marshaller_Anki_Vector_external_interface_MoveHeadRequest,
        __Marshaller_Anki_Vector_external_interface_MoveHeadResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.MoveLiftRequest, global::Anki.Vector.ExternalInterface.MoveLiftResponse> __Method_MoveLift = new grpc::Method<global::Anki.Vector.ExternalInterface.MoveLiftRequest, global::Anki.Vector.ExternalInterface.MoveLiftResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "MoveLift",
        __Marshaller_Anki_Vector_external_interface_MoveLiftRequest,
        __Marshaller_Anki_Vector_external_interface_MoveLiftResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.StopAllMotorsRequest, global::Anki.Vector.ExternalInterface.StopAllMotorsResponse> __Method_StopAllMotors = new grpc::Method<global::Anki.Vector.ExternalInterface.StopAllMotorsRequest, global::Anki.Vector.ExternalInterface.StopAllMotorsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "StopAllMotors",
        __Marshaller_Anki_Vector_external_interface_StopAllMotorsRequest,
        __Marshaller_Anki_Vector_external_interface_StopAllMotorsResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest, global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse> __Method_DisplayFaceImageRGB = new grpc::Method<global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest, global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DisplayFaceImageRGB",
        __Marshaller_Anki_Vector_external_interface_DisplayFaceImageRGBRequest,
        __Marshaller_Anki_Vector_external_interface_DisplayFaceImageRGBResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EventRequest, global::Anki.Vector.ExternalInterface.EventResponse> __Method_EventStream = new grpc::Method<global::Anki.Vector.ExternalInterface.EventRequest, global::Anki.Vector.ExternalInterface.EventResponse>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "EventStream",
        __Marshaller_Anki_Vector_external_interface_EventRequest,
        __Marshaller_Anki_Vector_external_interface_EventResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.ExternalAudioStreamRequest, global::Anki.Vector.ExternalInterface.ExternalAudioStreamResponse> __Method_ExternalAudioStreamPlayback = new grpc::Method<global::Anki.Vector.ExternalInterface.ExternalAudioStreamRequest, global::Anki.Vector.ExternalInterface.ExternalAudioStreamResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "ExternalAudioStreamPlayback",
        __Marshaller_Anki_Vector_external_interface_ExternalAudioStreamRequest,
        __Marshaller_Anki_Vector_external_interface_ExternalAudioStreamResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.BehaviorControlRequest, global::Anki.Vector.ExternalInterface.BehaviorControlResponse> __Method_BehaviorControl = new grpc::Method<global::Anki.Vector.ExternalInterface.BehaviorControlRequest, global::Anki.Vector.ExternalInterface.BehaviorControlResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "BehaviorControl",
        __Marshaller_Anki_Vector_external_interface_BehaviorControlRequest,
        __Marshaller_Anki_Vector_external_interface_BehaviorControlResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.BehaviorControlRequest, global::Anki.Vector.ExternalInterface.BehaviorControlResponse> __Method_AssumeBehaviorControl = new grpc::Method<global::Anki.Vector.ExternalInterface.BehaviorControlRequest, global::Anki.Vector.ExternalInterface.BehaviorControlResponse>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "AssumeBehaviorControl",
        __Marshaller_Anki_Vector_external_interface_BehaviorControlRequest,
        __Marshaller_Anki_Vector_external_interface_BehaviorControlResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest, global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse> __Method_CancelFaceEnrollment = new grpc::Method<global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest, global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CancelFaceEnrollment",
        __Marshaller_Anki_Vector_external_interface_CancelFaceEnrollmentRequest,
        __Marshaller_Anki_Vector_external_interface_CancelFaceEnrollmentResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest, global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse> __Method_RequestEnrolledNames = new grpc::Method<global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest, global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RequestEnrolledNames",
        __Marshaller_Anki_Vector_external_interface_RequestEnrolledNamesRequest,
        __Marshaller_Anki_Vector_external_interface_RequestEnrolledNamesResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest, global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse> __Method_UpdateEnrolledFaceByID = new grpc::Method<global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest, global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "UpdateEnrolledFaceByID",
        __Marshaller_Anki_Vector_external_interface_UpdateEnrolledFaceByIDRequest,
        __Marshaller_Anki_Vector_external_interface_UpdateEnrolledFaceByIDResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest, global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse> __Method_EraseEnrolledFaceByID = new grpc::Method<global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest, global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EraseEnrolledFaceByID",
        __Marshaller_Anki_Vector_external_interface_EraseEnrolledFaceByIDRequest,
        __Marshaller_Anki_Vector_external_interface_EraseEnrolledFaceByIDResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest, global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse> __Method_EraseAllEnrolledFaces = new grpc::Method<global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest, global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EraseAllEnrolledFaces",
        __Marshaller_Anki_Vector_external_interface_EraseAllEnrolledFacesRequest,
        __Marshaller_Anki_Vector_external_interface_EraseAllEnrolledFacesResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest, global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse> __Method_SetFaceToEnroll = new grpc::Method<global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest, global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetFaceToEnroll",
        __Marshaller_Anki_Vector_external_interface_SetFaceToEnrollRequest,
        __Marshaller_Anki_Vector_external_interface_SetFaceToEnrollResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest, global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse> __Method_EnableMarkerDetection = new grpc::Method<global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest, global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EnableMarkerDetection",
        __Marshaller_Anki_Vector_external_interface_EnableMarkerDetectionRequest,
        __Marshaller_Anki_Vector_external_interface_EnableMarkerDetectionResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest, global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse> __Method_EnableFaceDetection = new grpc::Method<global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest, global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EnableFaceDetection",
        __Marshaller_Anki_Vector_external_interface_EnableFaceDetectionRequest,
        __Marshaller_Anki_Vector_external_interface_EnableFaceDetectionResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest, global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse> __Method_EnableMotionDetection = new grpc::Method<global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest, global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EnableMotionDetection",
        __Marshaller_Anki_Vector_external_interface_EnableMotionDetectionRequest,
        __Marshaller_Anki_Vector_external_interface_EnableMotionDetectionResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest, global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse> __Method_EnableMirrorMode = new grpc::Method<global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest, global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EnableMirrorMode",
        __Marshaller_Anki_Vector_external_interface_EnableMirrorModeRequest,
        __Marshaller_Anki_Vector_external_interface_EnableMirrorModeResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest, global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse> __Method_EnableImageStreaming = new grpc::Method<global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest, global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EnableImageStreaming",
        __Marshaller_Anki_Vector_external_interface_EnableImageStreamingRequest,
        __Marshaller_Anki_Vector_external_interface_EnableImageStreamingResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest, global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse> __Method_IsImageStreamingEnabled = new grpc::Method<global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest, global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "IsImageStreamingEnabled",
        __Marshaller_Anki_Vector_external_interface_IsImageStreamingEnabledRequest,
        __Marshaller_Anki_Vector_external_interface_IsImageStreamingEnabledResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest, global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse> __Method_CancelActionByIdTag = new grpc::Method<global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest, global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CancelActionByIdTag",
        __Marshaller_Anki_Vector_external_interface_CancelActionByIdTagRequest,
        __Marshaller_Anki_Vector_external_interface_CancelActionByIdTagResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.GoToPoseRequest, global::Anki.Vector.ExternalInterface.GoToPoseResponse> __Method_GoToPose = new grpc::Method<global::Anki.Vector.ExternalInterface.GoToPoseRequest, global::Anki.Vector.ExternalInterface.GoToPoseResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GoToPose",
        __Marshaller_Anki_Vector_external_interface_GoToPoseRequest,
        __Marshaller_Anki_Vector_external_interface_GoToPoseResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DockWithCubeRequest, global::Anki.Vector.ExternalInterface.DockWithCubeResponse> __Method_DockWithCube = new grpc::Method<global::Anki.Vector.ExternalInterface.DockWithCubeRequest, global::Anki.Vector.ExternalInterface.DockWithCubeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DockWithCube",
        __Marshaller_Anki_Vector_external_interface_DockWithCubeRequest,
        __Marshaller_Anki_Vector_external_interface_DockWithCubeResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DriveOffChargerRequest, global::Anki.Vector.ExternalInterface.DriveOffChargerResponse> __Method_DriveOffCharger = new grpc::Method<global::Anki.Vector.ExternalInterface.DriveOffChargerRequest, global::Anki.Vector.ExternalInterface.DriveOffChargerResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DriveOffCharger",
        __Marshaller_Anki_Vector_external_interface_DriveOffChargerRequest,
        __Marshaller_Anki_Vector_external_interface_DriveOffChargerResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DriveOnChargerRequest, global::Anki.Vector.ExternalInterface.DriveOnChargerResponse> __Method_DriveOnCharger = new grpc::Method<global::Anki.Vector.ExternalInterface.DriveOnChargerRequest, global::Anki.Vector.ExternalInterface.DriveOnChargerResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DriveOnCharger",
        __Marshaller_Anki_Vector_external_interface_DriveOnChargerRequest,
        __Marshaller_Anki_Vector_external_interface_DriveOnChargerResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.FindFacesRequest, global::Anki.Vector.ExternalInterface.FindFacesResponse> __Method_FindFaces = new grpc::Method<global::Anki.Vector.ExternalInterface.FindFacesRequest, global::Anki.Vector.ExternalInterface.FindFacesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "FindFaces",
        __Marshaller_Anki_Vector_external_interface_FindFacesRequest,
        __Marshaller_Anki_Vector_external_interface_FindFacesResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest, global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse> __Method_LookAroundInPlace = new grpc::Method<global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest, global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "LookAroundInPlace",
        __Marshaller_Anki_Vector_external_interface_LookAroundInPlaceRequest,
        __Marshaller_Anki_Vector_external_interface_LookAroundInPlaceResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.RollBlockRequest, global::Anki.Vector.ExternalInterface.RollBlockResponse> __Method_RollBlock = new grpc::Method<global::Anki.Vector.ExternalInterface.RollBlockRequest, global::Anki.Vector.ExternalInterface.RollBlockResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RollBlock",
        __Marshaller_Anki_Vector_external_interface_RollBlockRequest,
        __Marshaller_Anki_Vector_external_interface_RollBlockResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.PhotosInfoRequest, global::Anki.Vector.ExternalInterface.PhotosInfoResponse> __Method_PhotosInfo = new grpc::Method<global::Anki.Vector.ExternalInterface.PhotosInfoRequest, global::Anki.Vector.ExternalInterface.PhotosInfoResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PhotosInfo",
        __Marshaller_Anki_Vector_external_interface_PhotosInfoRequest,
        __Marshaller_Anki_Vector_external_interface_PhotosInfoResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.PhotoRequest, global::Anki.Vector.ExternalInterface.PhotoResponse> __Method_Photo = new grpc::Method<global::Anki.Vector.ExternalInterface.PhotoRequest, global::Anki.Vector.ExternalInterface.PhotoResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Photo",
        __Marshaller_Anki_Vector_external_interface_PhotoRequest,
        __Marshaller_Anki_Vector_external_interface_PhotoResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.ThumbnailRequest, global::Anki.Vector.ExternalInterface.ThumbnailResponse> __Method_Thumbnail = new grpc::Method<global::Anki.Vector.ExternalInterface.ThumbnailRequest, global::Anki.Vector.ExternalInterface.ThumbnailResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Thumbnail",
        __Marshaller_Anki_Vector_external_interface_ThumbnailRequest,
        __Marshaller_Anki_Vector_external_interface_ThumbnailResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DeletePhotoRequest, global::Anki.Vector.ExternalInterface.DeletePhotoResponse> __Method_DeletePhoto = new grpc::Method<global::Anki.Vector.ExternalInterface.DeletePhotoRequest, global::Anki.Vector.ExternalInterface.DeletePhotoResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeletePhoto",
        __Marshaller_Anki_Vector_external_interface_DeletePhotoRequest,
        __Marshaller_Anki_Vector_external_interface_DeletePhotoResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DriveStraightRequest, global::Anki.Vector.ExternalInterface.DriveStraightResponse> __Method_DriveStraight = new grpc::Method<global::Anki.Vector.ExternalInterface.DriveStraightRequest, global::Anki.Vector.ExternalInterface.DriveStraightResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DriveStraight",
        __Marshaller_Anki_Vector_external_interface_DriveStraightRequest,
        __Marshaller_Anki_Vector_external_interface_DriveStraightResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.TurnInPlaceRequest, global::Anki.Vector.ExternalInterface.TurnInPlaceResponse> __Method_TurnInPlace = new grpc::Method<global::Anki.Vector.ExternalInterface.TurnInPlaceRequest, global::Anki.Vector.ExternalInterface.TurnInPlaceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "TurnInPlace",
        __Marshaller_Anki_Vector_external_interface_TurnInPlaceRequest,
        __Marshaller_Anki_Vector_external_interface_TurnInPlaceResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SetHeadAngleRequest, global::Anki.Vector.ExternalInterface.SetHeadAngleResponse> __Method_SetHeadAngle = new grpc::Method<global::Anki.Vector.ExternalInterface.SetHeadAngleRequest, global::Anki.Vector.ExternalInterface.SetHeadAngleResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetHeadAngle",
        __Marshaller_Anki_Vector_external_interface_SetHeadAngleRequest,
        __Marshaller_Anki_Vector_external_interface_SetHeadAngleResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SetLiftHeightRequest, global::Anki.Vector.ExternalInterface.SetLiftHeightResponse> __Method_SetLiftHeight = new grpc::Method<global::Anki.Vector.ExternalInterface.SetLiftHeightRequest, global::Anki.Vector.ExternalInterface.SetLiftHeightResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetLiftHeight",
        __Marshaller_Anki_Vector_external_interface_SetLiftHeightRequest,
        __Marshaller_Anki_Vector_external_interface_SetLiftHeightResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest, global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse> __Method_TurnTowardsFace = new grpc::Method<global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest, global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "TurnTowardsFace",
        __Marshaller_Anki_Vector_external_interface_TurnTowardsFaceRequest,
        __Marshaller_Anki_Vector_external_interface_TurnTowardsFaceResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.GoToObjectRequest, global::Anki.Vector.ExternalInterface.GoToObjectResponse> __Method_GoToObject = new grpc::Method<global::Anki.Vector.ExternalInterface.GoToObjectRequest, global::Anki.Vector.ExternalInterface.GoToObjectResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GoToObject",
        __Marshaller_Anki_Vector_external_interface_GoToObjectRequest,
        __Marshaller_Anki_Vector_external_interface_GoToObjectResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.RollObjectRequest, global::Anki.Vector.ExternalInterface.RollObjectResponse> __Method_RollObject = new grpc::Method<global::Anki.Vector.ExternalInterface.RollObjectRequest, global::Anki.Vector.ExternalInterface.RollObjectResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RollObject",
        __Marshaller_Anki_Vector_external_interface_RollObjectRequest,
        __Marshaller_Anki_Vector_external_interface_RollObjectResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.PopAWheelieRequest, global::Anki.Vector.ExternalInterface.PopAWheelieResponse> __Method_PopAWheelie = new grpc::Method<global::Anki.Vector.ExternalInterface.PopAWheelieRequest, global::Anki.Vector.ExternalInterface.PopAWheelieResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PopAWheelie",
        __Marshaller_Anki_Vector_external_interface_PopAWheelieRequest,
        __Marshaller_Anki_Vector_external_interface_PopAWheelieResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.PickupObjectRequest, global::Anki.Vector.ExternalInterface.PickupObjectResponse> __Method_PickupObject = new grpc::Method<global::Anki.Vector.ExternalInterface.PickupObjectRequest, global::Anki.Vector.ExternalInterface.PickupObjectResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PickupObject",
        __Marshaller_Anki_Vector_external_interface_PickupObjectRequest,
        __Marshaller_Anki_Vector_external_interface_PickupObjectResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest, global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse> __Method_PlaceObjectOnGroundHere = new grpc::Method<global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest, global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PlaceObjectOnGroundHere",
        __Marshaller_Anki_Vector_external_interface_PlaceObjectOnGroundHereRequest,
        __Marshaller_Anki_Vector_external_interface_PlaceObjectOnGroundHereResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.MasterVolumeRequest, global::Anki.Vector.ExternalInterface.MasterVolumeResponse> __Method_SetMasterVolume = new grpc::Method<global::Anki.Vector.ExternalInterface.MasterVolumeRequest, global::Anki.Vector.ExternalInterface.MasterVolumeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetMasterVolume",
        __Marshaller_Anki_Vector_external_interface_MasterVolumeRequest,
        __Marshaller_Anki_Vector_external_interface_MasterVolumeResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.UserAuthenticationRequest, global::Anki.Vector.ExternalInterface.UserAuthenticationResponse> __Method_UserAuthentication = new grpc::Method<global::Anki.Vector.ExternalInterface.UserAuthenticationRequest, global::Anki.Vector.ExternalInterface.UserAuthenticationResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "UserAuthentication",
        __Marshaller_Anki_Vector_external_interface_UserAuthenticationRequest,
        __Marshaller_Anki_Vector_external_interface_UserAuthenticationResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.BatteryStateRequest, global::Anki.Vector.ExternalInterface.BatteryStateResponse> __Method_BatteryState = new grpc::Method<global::Anki.Vector.ExternalInterface.BatteryStateRequest, global::Anki.Vector.ExternalInterface.BatteryStateResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "BatteryState",
        __Marshaller_Anki_Vector_external_interface_BatteryStateRequest,
        __Marshaller_Anki_Vector_external_interface_BatteryStateResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.VersionStateRequest, global::Anki.Vector.ExternalInterface.VersionStateResponse> __Method_VersionState = new grpc::Method<global::Anki.Vector.ExternalInterface.VersionStateRequest, global::Anki.Vector.ExternalInterface.VersionStateResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "VersionState",
        __Marshaller_Anki_Vector_external_interface_VersionStateRequest,
        __Marshaller_Anki_Vector_external_interface_VersionStateResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SayTextRequest, global::Anki.Vector.ExternalInterface.SayTextResponse> __Method_SayText = new grpc::Method<global::Anki.Vector.ExternalInterface.SayTextRequest, global::Anki.Vector.ExternalInterface.SayTextResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SayText",
        __Marshaller_Anki_Vector_external_interface_SayTextRequest,
        __Marshaller_Anki_Vector_external_interface_SayTextResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.ConnectCubeRequest, global::Anki.Vector.ExternalInterface.ConnectCubeResponse> __Method_ConnectCube = new grpc::Method<global::Anki.Vector.ExternalInterface.ConnectCubeRequest, global::Anki.Vector.ExternalInterface.ConnectCubeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ConnectCube",
        __Marshaller_Anki_Vector_external_interface_ConnectCubeRequest,
        __Marshaller_Anki_Vector_external_interface_ConnectCubeResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DisconnectCubeRequest, global::Anki.Vector.ExternalInterface.DisconnectCubeResponse> __Method_DisconnectCube = new grpc::Method<global::Anki.Vector.ExternalInterface.DisconnectCubeRequest, global::Anki.Vector.ExternalInterface.DisconnectCubeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DisconnectCube",
        __Marshaller_Anki_Vector_external_interface_DisconnectCubeRequest,
        __Marshaller_Anki_Vector_external_interface_DisconnectCubeResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.CubesAvailableRequest, global::Anki.Vector.ExternalInterface.CubesAvailableResponse> __Method_CubesAvailable = new grpc::Method<global::Anki.Vector.ExternalInterface.CubesAvailableRequest, global::Anki.Vector.ExternalInterface.CubesAvailableResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CubesAvailable",
        __Marshaller_Anki_Vector_external_interface_CubesAvailableRequest,
        __Marshaller_Anki_Vector_external_interface_CubesAvailableResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest, global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse> __Method_FlashCubeLights = new grpc::Method<global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest, global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "FlashCubeLights",
        __Marshaller_Anki_Vector_external_interface_FlashCubeLightsRequest,
        __Marshaller_Anki_Vector_external_interface_FlashCubeLightsResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest, global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse> __Method_ForgetPreferredCube = new grpc::Method<global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest, global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ForgetPreferredCube",
        __Marshaller_Anki_Vector_external_interface_ForgetPreferredCubeRequest,
        __Marshaller_Anki_Vector_external_interface_ForgetPreferredCubeResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest, global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse> __Method_SetPreferredCube = new grpc::Method<global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest, global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetPreferredCube",
        __Marshaller_Anki_Vector_external_interface_SetPreferredCubeRequest,
        __Marshaller_Anki_Vector_external_interface_SetPreferredCubeResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest, global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse> __Method_DeleteCustomObjects = new grpc::Method<global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest, global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeleteCustomObjects",
        __Marshaller_Anki_Vector_external_interface_DeleteCustomObjectsRequest,
        __Marshaller_Anki_Vector_external_interface_DeleteCustomObjectsResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest, global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse> __Method_CreateFixedCustomObject = new grpc::Method<global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest, global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateFixedCustomObject",
        __Marshaller_Anki_Vector_external_interface_CreateFixedCustomObjectRequest,
        __Marshaller_Anki_Vector_external_interface_CreateFixedCustomObjectResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest, global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse> __Method_DefineCustomObject = new grpc::Method<global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest, global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DefineCustomObject",
        __Marshaller_Anki_Vector_external_interface_DefineCustomObjectRequest,
        __Marshaller_Anki_Vector_external_interface_DefineCustomObjectResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SetCubeLightsRequest, global::Anki.Vector.ExternalInterface.SetCubeLightsResponse> __Method_SetCubeLights = new grpc::Method<global::Anki.Vector.ExternalInterface.SetCubeLightsRequest, global::Anki.Vector.ExternalInterface.SetCubeLightsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetCubeLights",
        __Marshaller_Anki_Vector_external_interface_SetCubeLightsRequest,
        __Marshaller_Anki_Vector_external_interface_SetCubeLightsResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.AudioFeedRequest, global::Anki.Vector.ExternalInterface.AudioFeedResponse> __Method_AudioFeed = new grpc::Method<global::Anki.Vector.ExternalInterface.AudioFeedRequest, global::Anki.Vector.ExternalInterface.AudioFeedResponse>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "AudioFeed",
        __Marshaller_Anki_Vector_external_interface_AudioFeedRequest,
        __Marshaller_Anki_Vector_external_interface_AudioFeedResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.CameraFeedRequest, global::Anki.Vector.ExternalInterface.CameraFeedResponse> __Method_CameraFeed = new grpc::Method<global::Anki.Vector.ExternalInterface.CameraFeedRequest, global::Anki.Vector.ExternalInterface.CameraFeedResponse>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "CameraFeed",
        __Marshaller_Anki_Vector_external_interface_CameraFeedRequest,
        __Marshaller_Anki_Vector_external_interface_CameraFeedResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest, global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse> __Method_CaptureSingleImage = new grpc::Method<global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest, global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CaptureSingleImage",
        __Marshaller_Anki_Vector_external_interface_CaptureSingleImageRequest,
        __Marshaller_Anki_Vector_external_interface_CaptureSingleImageResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.SetEyeColorRequest, global::Anki.Vector.ExternalInterface.SetEyeColorResponse> __Method_SetEyeColor = new grpc::Method<global::Anki.Vector.ExternalInterface.SetEyeColorRequest, global::Anki.Vector.ExternalInterface.SetEyeColorResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetEyeColor",
        __Marshaller_Anki_Vector_external_interface_SetEyeColorRequest,
        __Marshaller_Anki_Vector_external_interface_SetEyeColorResponse);

    static readonly grpc::Method<global::Anki.Vector.ExternalInterface.NavMapFeedRequest, global::Anki.Vector.ExternalInterface.NavMapFeedResponse> __Method_NavMapFeed = new grpc::Method<global::Anki.Vector.ExternalInterface.NavMapFeedRequest, global::Anki.Vector.ExternalInterface.NavMapFeedResponse>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "NavMapFeed",
        __Marshaller_Anki_Vector_external_interface_NavMapFeedRequest,
        __Marshaller_Anki_Vector_external_interface_NavMapFeedResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Anki.Vector.ExternalInterface.ExternalInterfaceReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of ExternalInterface</summary>
    public abstract partial class ExternalInterfaceBase
    {
      /// <summary>
      /// Checks the supported protocol version by passing in the client version and
      /// minimum host version and receiving a response to see whether the versions are supported.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.ProtocolVersionResponse> ProtocolVersion(global::Anki.Vector.ExternalInterface.ProtocolVersionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// SDK-only message to pass version info for device OS, Python version, etc.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SDKInitializationResponse> SDKInitialization(global::Anki.Vector.ExternalInterface.SDKInitializationRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Sets the speed and acceleration for Vector's wheel motors.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DriveWheelsResponse> DriveWheels(global::Anki.Vector.ExternalInterface.DriveWheelsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Requests that Vector play an animation trigger.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.PlayAnimationResponse> PlayAnimationTrigger(global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Requests that Vector play an animation.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.PlayAnimationResponse> PlayAnimation(global::Anki.Vector.ExternalInterface.PlayAnimationRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Constructs and returns a list of animations.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.ListAnimationsResponse> ListAnimations(global::Anki.Vector.ExternalInterface.ListAnimationsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Constructs and returns a list of animation triggers.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse> ListAnimationTriggers(global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Moves Vector's head.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.MoveHeadResponse> MoveHead(global::Anki.Vector.ExternalInterface.MoveHeadRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Moves Vector's lift.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.MoveLiftResponse> MoveLift(global::Anki.Vector.ExternalInterface.MoveLiftRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Stop all motor commands requested: MoveHead, MoveLift and DriveWheels.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.StopAllMotorsResponse> StopAllMotors(global::Anki.Vector.ExternalInterface.StopAllMotorsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Sets screen (Vector's face) to a solid color.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse> DisplayFaceImageRGB(global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Streaming events endpoint
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task EventStream(global::Anki.Vector.ExternalInterface.EventRequest request, grpc::IServerStreamWriter<global::Anki.Vector.ExternalInterface.EventResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Play audio using Vector's speaker
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task ExternalAudioStreamPlayback(grpc::IAsyncStreamReader<global::Anki.Vector.ExternalInterface.ExternalAudioStreamRequest> requestStream, grpc::IServerStreamWriter<global::Anki.Vector.ExternalInterface.ExternalAudioStreamResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Integrate with and acquire control of Vector's AI system.
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task BehaviorControl(grpc::IAsyncStreamReader<global::Anki.Vector.ExternalInterface.BehaviorControlRequest> requestStream, grpc::IServerStreamWriter<global::Anki.Vector.ExternalInterface.BehaviorControlResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Acquire control of Vector's AI system.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task AssumeBehaviorControl(global::Anki.Vector.ExternalInterface.BehaviorControlRequest request, grpc::IServerStreamWriter<global::Anki.Vector.ExternalInterface.BehaviorControlResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse> CancelFaceEnrollment(global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Get a list of names and their IDs.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse> RequestEnrolledNames(global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Update the name enrolled for a given face.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse> UpdateEnrolledFaceByID(global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Erase the enrollment (name) record for the face with this ID.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse> EraseEnrolledFaceByID(global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Erase the enrollment (name) records for all faces.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse> EraseAllEnrolledFaces(global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse> SetFaceToEnroll(global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse> EnableMarkerDetection(global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse> EnableFaceDetection(global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse> EnableMotionDetection(global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse> EnableMirrorMode(global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse> EnableImageStreaming(global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse> IsImageStreamingEnabled(global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Cancel action by id
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse> CancelActionByIdTag(global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tells Vector to drive to the specified pose and orientation.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.GoToPoseResponse> GoToPose(global::Anki.Vector.ExternalInterface.GoToPoseRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tells Vector to dock with a light cube with a given approach angle and distance.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DockWithCubeResponse> DockWithCube(global::Anki.Vector.ExternalInterface.DockWithCubeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Drive Vector off the charger.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DriveOffChargerResponse> DriveOffCharger(global::Anki.Vector.ExternalInterface.DriveOffChargerRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Drive Vector onto the charger.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DriveOnChargerResponse> DriveOnCharger(global::Anki.Vector.ExternalInterface.DriveOnChargerRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Make Vector look for faces by turning and angling his head
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.FindFacesResponse> FindFaces(global::Anki.Vector.ExternalInterface.FindFacesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Make Vector look around in place by turning and moving his head
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse> LookAroundInPlace(global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Make Vector roll his block, regardless of relative position and orientation
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.RollBlockResponse> RollBlock(global::Anki.Vector.ExternalInterface.RollBlockRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Get the photos info.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.PhotosInfoResponse> PhotosInfo(global::Anki.Vector.ExternalInterface.PhotosInfoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Get a photo by ID.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.PhotoResponse> Photo(global::Anki.Vector.ExternalInterface.PhotoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Get a thumbnail by ID.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.ThumbnailResponse> Thumbnail(global::Anki.Vector.ExternalInterface.ThumbnailRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Delete a photo by ID.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DeletePhotoResponse> DeletePhoto(global::Anki.Vector.ExternalInterface.DeletePhotoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tells Vector to drive in a straight line.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DriveStraightResponse> DriveStraight(global::Anki.Vector.ExternalInterface.DriveStraightRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Turn the robot around its current position.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.TurnInPlaceResponse> TurnInPlace(global::Anki.Vector.ExternalInterface.TurnInPlaceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tell Vector's head to move to a given angle.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SetHeadAngleResponse> SetHeadAngle(global::Anki.Vector.ExternalInterface.SetHeadAngleRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tell Vector's lift to move to a given height.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SetLiftHeightResponse> SetLiftHeight(global::Anki.Vector.ExternalInterface.SetLiftHeightRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tell Vector to turn towards this face.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse> TurnTowardsFace(global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tell Vector to drive to the specified object.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.GoToObjectResponse> GoToObject(global::Anki.Vector.ExternalInterface.GoToObjectRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tell Vector to roll his cube.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.RollObjectResponse> RollObject(global::Anki.Vector.ExternalInterface.RollObjectRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Tell Vector to "pop a wheelie" using his cube.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.PopAWheelieResponse> PopAWheelie(global::Anki.Vector.ExternalInterface.PopAWheelieRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Instruct the robot to pick up the supplied object.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.PickupObjectResponse> PickupObject(global::Anki.Vector.ExternalInterface.PickupObjectRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Ask Vector to place the object he is carrying on the ground at the current location.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse> PlaceObjectOnGroundHere(global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Set the Robot's master volume
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.MasterVolumeResponse> SetMasterVolume(global::Anki.Vector.ExternalInterface.MasterVolumeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.UserAuthenticationResponse> UserAuthentication(global::Anki.Vector.ExternalInterface.UserAuthenticationRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Check the current state of the battery.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.BatteryStateResponse> BatteryState(global::Anki.Vector.ExternalInterface.BatteryStateRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Get the versioning information for Vector.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.VersionStateResponse> VersionState(global::Anki.Vector.ExternalInterface.VersionStateRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Make Vector speak text.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SayTextResponse> SayText(global::Anki.Vector.ExternalInterface.SayTextRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Attempt to connect to a cube. If a cube is currently connected,
      /// this will do nothing.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.ConnectCubeResponse> ConnectCube(global::Anki.Vector.ExternalInterface.ConnectCubeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Requests a disconnection from the currently connected cube.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DisconnectCubeResponse> DisconnectCube(global::Anki.Vector.ExternalInterface.DisconnectCubeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.CubesAvailableResponse> CubesAvailable(global::Anki.Vector.ExternalInterface.CubesAvailableRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Signal a connected cube to flash its lights using the default cube
      /// flash animation.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse> FlashCubeLights(global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Forget the robot's preferred cube. This will cause the robot to
      /// connect to the cube with the highest RSSI (signal strength) next
      /// time a connection is requested. Saves this preference to disk.
      /// The next cube that the robot connects to will become its
      /// preferred cube.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse> ForgetPreferredCube(global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Set the robot's preferred cube and save it to disk. The robot
      /// will always attempt to connect to this cube if it is available.
      /// This is only used in simulation for now.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse> SetPreferredCube(global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Causes the robot to forget about custom objects it currently knows about.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse> DeleteCustomObjects(global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Creates a permanent custom object instance in the robot's world, with no connection to the vision system.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse> CreateFixedCustomObject(global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Creates a custom object with distinct custom marker(s).
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse> DefineCustomObject(global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Set each of the lights on the currently connected cube based on two
      /// rgb values each and timing data for how to transition between them.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SetCubeLightsResponse> SetCubeLights(global::Anki.Vector.ExternalInterface.SetCubeLightsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Request an audio feed from the robot.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task AudioFeed(global::Anki.Vector.ExternalInterface.AudioFeedRequest request, grpc::IServerStreamWriter<global::Anki.Vector.ExternalInterface.AudioFeedResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Request a camera feed from the robot.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task CameraFeed(global::Anki.Vector.ExternalInterface.CameraFeedRequest request, grpc::IServerStreamWriter<global::Anki.Vector.ExternalInterface.CameraFeedResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Request a single image to be captured and sent from the robot.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse> CaptureSingleImage(global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Set Vector's eye color.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Anki.Vector.ExternalInterface.SetEyeColorResponse> SetEyeColor(global::Anki.Vector.ExternalInterface.SetEyeColorRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Stream navigation map data.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task NavMapFeed(global::Anki.Vector.ExternalInterface.NavMapFeedRequest request, grpc::IServerStreamWriter<global::Anki.Vector.ExternalInterface.NavMapFeedResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for ExternalInterface</summary>
    public partial class ExternalInterfaceClient : grpc::ClientBase<ExternalInterfaceClient>
    {
      /// <summary>Creates a new client for ExternalInterface</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public ExternalInterfaceClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for ExternalInterface that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public ExternalInterfaceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected ExternalInterfaceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected ExternalInterfaceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// Checks the supported protocol version by passing in the client version and
      /// minimum host version and receiving a response to see whether the versions are supported.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ProtocolVersionResponse ProtocolVersion(global::Anki.Vector.ExternalInterface.ProtocolVersionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ProtocolVersion(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Checks the supported protocol version by passing in the client version and
      /// minimum host version and receiving a response to see whether the versions are supported.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ProtocolVersionResponse ProtocolVersion(global::Anki.Vector.ExternalInterface.ProtocolVersionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ProtocolVersion, null, options, request);
      }
      /// <summary>
      /// Checks the supported protocol version by passing in the client version and
      /// minimum host version and receiving a response to see whether the versions are supported.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ProtocolVersionResponse> ProtocolVersionAsync(global::Anki.Vector.ExternalInterface.ProtocolVersionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ProtocolVersionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Checks the supported protocol version by passing in the client version and
      /// minimum host version and receiving a response to see whether the versions are supported.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ProtocolVersionResponse> ProtocolVersionAsync(global::Anki.Vector.ExternalInterface.ProtocolVersionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ProtocolVersion, null, options, request);
      }
      /// <summary>
      /// SDK-only message to pass version info for device OS, Python version, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SDKInitializationResponse SDKInitialization(global::Anki.Vector.ExternalInterface.SDKInitializationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SDKInitialization(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SDK-only message to pass version info for device OS, Python version, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SDKInitializationResponse SDKInitialization(global::Anki.Vector.ExternalInterface.SDKInitializationRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SDKInitialization, null, options, request);
      }
      /// <summary>
      /// SDK-only message to pass version info for device OS, Python version, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SDKInitializationResponse> SDKInitializationAsync(global::Anki.Vector.ExternalInterface.SDKInitializationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SDKInitializationAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SDK-only message to pass version info for device OS, Python version, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SDKInitializationResponse> SDKInitializationAsync(global::Anki.Vector.ExternalInterface.SDKInitializationRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SDKInitialization, null, options, request);
      }
      /// <summary>
      /// Sets the speed and acceleration for Vector's wheel motors.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveWheelsResponse DriveWheels(global::Anki.Vector.ExternalInterface.DriveWheelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveWheels(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Sets the speed and acceleration for Vector's wheel motors.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveWheelsResponse DriveWheels(global::Anki.Vector.ExternalInterface.DriveWheelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DriveWheels, null, options, request);
      }
      /// <summary>
      /// Sets the speed and acceleration for Vector's wheel motors.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveWheelsResponse> DriveWheelsAsync(global::Anki.Vector.ExternalInterface.DriveWheelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveWheelsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Sets the speed and acceleration for Vector's wheel motors.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveWheelsResponse> DriveWheelsAsync(global::Anki.Vector.ExternalInterface.DriveWheelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DriveWheels, null, options, request);
      }
      /// <summary>
      /// Requests that Vector play an animation trigger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PlayAnimationResponse PlayAnimationTrigger(global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PlayAnimationTrigger(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Requests that Vector play an animation trigger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PlayAnimationResponse PlayAnimationTrigger(global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PlayAnimationTrigger, null, options, request);
      }
      /// <summary>
      /// Requests that Vector play an animation trigger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PlayAnimationResponse> PlayAnimationTriggerAsync(global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PlayAnimationTriggerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Requests that Vector play an animation trigger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PlayAnimationResponse> PlayAnimationTriggerAsync(global::Anki.Vector.ExternalInterface.PlayAnimationTriggerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PlayAnimationTrigger, null, options, request);
      }
      /// <summary>
      /// Requests that Vector play an animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PlayAnimationResponse PlayAnimation(global::Anki.Vector.ExternalInterface.PlayAnimationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PlayAnimation(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Requests that Vector play an animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PlayAnimationResponse PlayAnimation(global::Anki.Vector.ExternalInterface.PlayAnimationRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PlayAnimation, null, options, request);
      }
      /// <summary>
      /// Requests that Vector play an animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PlayAnimationResponse> PlayAnimationAsync(global::Anki.Vector.ExternalInterface.PlayAnimationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PlayAnimationAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Requests that Vector play an animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PlayAnimationResponse> PlayAnimationAsync(global::Anki.Vector.ExternalInterface.PlayAnimationRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PlayAnimation, null, options, request);
      }
      /// <summary>
      /// Constructs and returns a list of animations.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ListAnimationsResponse ListAnimations(global::Anki.Vector.ExternalInterface.ListAnimationsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListAnimations(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Constructs and returns a list of animations.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ListAnimationsResponse ListAnimations(global::Anki.Vector.ExternalInterface.ListAnimationsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListAnimations, null, options, request);
      }
      /// <summary>
      /// Constructs and returns a list of animations.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ListAnimationsResponse> ListAnimationsAsync(global::Anki.Vector.ExternalInterface.ListAnimationsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListAnimationsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Constructs and returns a list of animations.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ListAnimationsResponse> ListAnimationsAsync(global::Anki.Vector.ExternalInterface.ListAnimationsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListAnimations, null, options, request);
      }
      /// <summary>
      /// Constructs and returns a list of animation triggers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse ListAnimationTriggers(global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListAnimationTriggers(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Constructs and returns a list of animation triggers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse ListAnimationTriggers(global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListAnimationTriggers, null, options, request);
      }
      /// <summary>
      /// Constructs and returns a list of animation triggers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse> ListAnimationTriggersAsync(global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListAnimationTriggersAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Constructs and returns a list of animation triggers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ListAnimationTriggersResponse> ListAnimationTriggersAsync(global::Anki.Vector.ExternalInterface.ListAnimationTriggersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListAnimationTriggers, null, options, request);
      }
      /// <summary>
      /// Moves Vector's head.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.MoveHeadResponse MoveHead(global::Anki.Vector.ExternalInterface.MoveHeadRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return MoveHead(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Moves Vector's head.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.MoveHeadResponse MoveHead(global::Anki.Vector.ExternalInterface.MoveHeadRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_MoveHead, null, options, request);
      }
      /// <summary>
      /// Moves Vector's head.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.MoveHeadResponse> MoveHeadAsync(global::Anki.Vector.ExternalInterface.MoveHeadRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return MoveHeadAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Moves Vector's head.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.MoveHeadResponse> MoveHeadAsync(global::Anki.Vector.ExternalInterface.MoveHeadRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_MoveHead, null, options, request);
      }
      /// <summary>
      /// Moves Vector's lift.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.MoveLiftResponse MoveLift(global::Anki.Vector.ExternalInterface.MoveLiftRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return MoveLift(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Moves Vector's lift.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.MoveLiftResponse MoveLift(global::Anki.Vector.ExternalInterface.MoveLiftRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_MoveLift, null, options, request);
      }
      /// <summary>
      /// Moves Vector's lift.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.MoveLiftResponse> MoveLiftAsync(global::Anki.Vector.ExternalInterface.MoveLiftRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return MoveLiftAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Moves Vector's lift.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.MoveLiftResponse> MoveLiftAsync(global::Anki.Vector.ExternalInterface.MoveLiftRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_MoveLift, null, options, request);
      }
      /// <summary>
      /// Stop all motor commands requested: MoveHead, MoveLift and DriveWheels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.StopAllMotorsResponse StopAllMotors(global::Anki.Vector.ExternalInterface.StopAllMotorsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return StopAllMotors(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Stop all motor commands requested: MoveHead, MoveLift and DriveWheels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.StopAllMotorsResponse StopAllMotors(global::Anki.Vector.ExternalInterface.StopAllMotorsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_StopAllMotors, null, options, request);
      }
      /// <summary>
      /// Stop all motor commands requested: MoveHead, MoveLift and DriveWheels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.StopAllMotorsResponse> StopAllMotorsAsync(global::Anki.Vector.ExternalInterface.StopAllMotorsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return StopAllMotorsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Stop all motor commands requested: MoveHead, MoveLift and DriveWheels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.StopAllMotorsResponse> StopAllMotorsAsync(global::Anki.Vector.ExternalInterface.StopAllMotorsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_StopAllMotors, null, options, request);
      }
      /// <summary>
      /// Sets screen (Vector's face) to a solid color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse DisplayFaceImageRGB(global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DisplayFaceImageRGB(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Sets screen (Vector's face) to a solid color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse DisplayFaceImageRGB(global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DisplayFaceImageRGB, null, options, request);
      }
      /// <summary>
      /// Sets screen (Vector's face) to a solid color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse> DisplayFaceImageRGBAsync(global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DisplayFaceImageRGBAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Sets screen (Vector's face) to a solid color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBResponse> DisplayFaceImageRGBAsync(global::Anki.Vector.ExternalInterface.DisplayFaceImageRGBRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DisplayFaceImageRGB, null, options, request);
      }
      /// <summary>
      /// Streaming events endpoint
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.EventResponse> EventStream(global::Anki.Vector.ExternalInterface.EventRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EventStream(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Streaming events endpoint
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.EventResponse> EventStream(global::Anki.Vector.ExternalInterface.EventRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_EventStream, null, options, request);
      }
      /// <summary>
      /// Play audio using Vector's speaker
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Anki.Vector.ExternalInterface.ExternalAudioStreamRequest, global::Anki.Vector.ExternalInterface.ExternalAudioStreamResponse> ExternalAudioStreamPlayback(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ExternalAudioStreamPlayback(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Play audio using Vector's speaker
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Anki.Vector.ExternalInterface.ExternalAudioStreamRequest, global::Anki.Vector.ExternalInterface.ExternalAudioStreamResponse> ExternalAudioStreamPlayback(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_ExternalAudioStreamPlayback, null, options);
      }
      /// <summary>
      /// Integrate with and acquire control of Vector's AI system.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Anki.Vector.ExternalInterface.BehaviorControlRequest, global::Anki.Vector.ExternalInterface.BehaviorControlResponse> BehaviorControl(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return BehaviorControl(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Integrate with and acquire control of Vector's AI system.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Anki.Vector.ExternalInterface.BehaviorControlRequest, global::Anki.Vector.ExternalInterface.BehaviorControlResponse> BehaviorControl(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_BehaviorControl, null, options);
      }
      /// <summary>
      /// Acquire control of Vector's AI system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.BehaviorControlResponse> AssumeBehaviorControl(global::Anki.Vector.ExternalInterface.BehaviorControlRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AssumeBehaviorControl(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Acquire control of Vector's AI system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.BehaviorControlResponse> AssumeBehaviorControl(global::Anki.Vector.ExternalInterface.BehaviorControlRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_AssumeBehaviorControl, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse CancelFaceEnrollment(global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelFaceEnrollment(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse CancelFaceEnrollment(global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CancelFaceEnrollment, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse> CancelFaceEnrollmentAsync(global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelFaceEnrollmentAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentResponse> CancelFaceEnrollmentAsync(global::Anki.Vector.ExternalInterface.CancelFaceEnrollmentRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CancelFaceEnrollment, null, options, request);
      }
      /// <summary>
      /// Get a list of names and their IDs.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse RequestEnrolledNames(global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RequestEnrolledNames(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get a list of names and their IDs.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse RequestEnrolledNames(global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RequestEnrolledNames, null, options, request);
      }
      /// <summary>
      /// Get a list of names and their IDs.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse> RequestEnrolledNamesAsync(global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RequestEnrolledNamesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get a list of names and their IDs.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.RequestEnrolledNamesResponse> RequestEnrolledNamesAsync(global::Anki.Vector.ExternalInterface.RequestEnrolledNamesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RequestEnrolledNames, null, options, request);
      }
      /// <summary>
      /// Update the name enrolled for a given face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse UpdateEnrolledFaceByID(global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateEnrolledFaceByID(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Update the name enrolled for a given face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse UpdateEnrolledFaceByID(global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_UpdateEnrolledFaceByID, null, options, request);
      }
      /// <summary>
      /// Update the name enrolled for a given face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse> UpdateEnrolledFaceByIDAsync(global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateEnrolledFaceByIDAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Update the name enrolled for a given face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDResponse> UpdateEnrolledFaceByIDAsync(global::Anki.Vector.ExternalInterface.UpdateEnrolledFaceByIDRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_UpdateEnrolledFaceByID, null, options, request);
      }
      /// <summary>
      /// Erase the enrollment (name) record for the face with this ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse EraseEnrolledFaceByID(global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EraseEnrolledFaceByID(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Erase the enrollment (name) record for the face with this ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse EraseEnrolledFaceByID(global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EraseEnrolledFaceByID, null, options, request);
      }
      /// <summary>
      /// Erase the enrollment (name) record for the face with this ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse> EraseEnrolledFaceByIDAsync(global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EraseEnrolledFaceByIDAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Erase the enrollment (name) record for the face with this ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDResponse> EraseEnrolledFaceByIDAsync(global::Anki.Vector.ExternalInterface.EraseEnrolledFaceByIDRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EraseEnrolledFaceByID, null, options, request);
      }
      /// <summary>
      /// Erase the enrollment (name) records for all faces.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse EraseAllEnrolledFaces(global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EraseAllEnrolledFaces(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Erase the enrollment (name) records for all faces.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse EraseAllEnrolledFaces(global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EraseAllEnrolledFaces, null, options, request);
      }
      /// <summary>
      /// Erase the enrollment (name) records for all faces.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse> EraseAllEnrolledFacesAsync(global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EraseAllEnrolledFacesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Erase the enrollment (name) records for all faces.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesResponse> EraseAllEnrolledFacesAsync(global::Anki.Vector.ExternalInterface.EraseAllEnrolledFacesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EraseAllEnrolledFaces, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse SetFaceToEnroll(global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetFaceToEnroll(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse SetFaceToEnroll(global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetFaceToEnroll, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse> SetFaceToEnrollAsync(global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetFaceToEnrollAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetFaceToEnrollResponse> SetFaceToEnrollAsync(global::Anki.Vector.ExternalInterface.SetFaceToEnrollRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetFaceToEnroll, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse EnableMarkerDetection(global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableMarkerDetection(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse EnableMarkerDetection(global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EnableMarkerDetection, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse> EnableMarkerDetectionAsync(global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableMarkerDetectionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableMarkerDetectionResponse> EnableMarkerDetectionAsync(global::Anki.Vector.ExternalInterface.EnableMarkerDetectionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EnableMarkerDetection, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse EnableFaceDetection(global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableFaceDetection(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse EnableFaceDetection(global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EnableFaceDetection, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse> EnableFaceDetectionAsync(global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableFaceDetectionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableFaceDetectionResponse> EnableFaceDetectionAsync(global::Anki.Vector.ExternalInterface.EnableFaceDetectionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EnableFaceDetection, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse EnableMotionDetection(global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableMotionDetection(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse EnableMotionDetection(global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EnableMotionDetection, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse> EnableMotionDetectionAsync(global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableMotionDetectionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableMotionDetectionResponse> EnableMotionDetectionAsync(global::Anki.Vector.ExternalInterface.EnableMotionDetectionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EnableMotionDetection, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse EnableMirrorMode(global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableMirrorMode(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse EnableMirrorMode(global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EnableMirrorMode, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse> EnableMirrorModeAsync(global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableMirrorModeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableMirrorModeResponse> EnableMirrorModeAsync(global::Anki.Vector.ExternalInterface.EnableMirrorModeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EnableMirrorMode, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse EnableImageStreaming(global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableImageStreaming(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse EnableImageStreaming(global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EnableImageStreaming, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse> EnableImageStreamingAsync(global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EnableImageStreamingAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.EnableImageStreamingResponse> EnableImageStreamingAsync(global::Anki.Vector.ExternalInterface.EnableImageStreamingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EnableImageStreaming, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse IsImageStreamingEnabled(global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return IsImageStreamingEnabled(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse IsImageStreamingEnabled(global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_IsImageStreamingEnabled, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse> IsImageStreamingEnabledAsync(global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return IsImageStreamingEnabledAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledResponse> IsImageStreamingEnabledAsync(global::Anki.Vector.ExternalInterface.IsImageStreamingEnabledRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_IsImageStreamingEnabled, null, options, request);
      }
      /// <summary>
      /// Cancel action by id
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse CancelActionByIdTag(global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelActionByIdTag(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Cancel action by id
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse CancelActionByIdTag(global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CancelActionByIdTag, null, options, request);
      }
      /// <summary>
      /// Cancel action by id
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse> CancelActionByIdTagAsync(global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelActionByIdTagAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Cancel action by id
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CancelActionByIdTagResponse> CancelActionByIdTagAsync(global::Anki.Vector.ExternalInterface.CancelActionByIdTagRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CancelActionByIdTag, null, options, request);
      }
      /// <summary>
      /// Tells Vector to drive to the specified pose and orientation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.GoToPoseResponse GoToPose(global::Anki.Vector.ExternalInterface.GoToPoseRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GoToPose(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tells Vector to drive to the specified pose and orientation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.GoToPoseResponse GoToPose(global::Anki.Vector.ExternalInterface.GoToPoseRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GoToPose, null, options, request);
      }
      /// <summary>
      /// Tells Vector to drive to the specified pose and orientation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.GoToPoseResponse> GoToPoseAsync(global::Anki.Vector.ExternalInterface.GoToPoseRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GoToPoseAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tells Vector to drive to the specified pose and orientation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.GoToPoseResponse> GoToPoseAsync(global::Anki.Vector.ExternalInterface.GoToPoseRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GoToPose, null, options, request);
      }
      /// <summary>
      /// Tells Vector to dock with a light cube with a given approach angle and distance.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DockWithCubeResponse DockWithCube(global::Anki.Vector.ExternalInterface.DockWithCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DockWithCube(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tells Vector to dock with a light cube with a given approach angle and distance.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DockWithCubeResponse DockWithCube(global::Anki.Vector.ExternalInterface.DockWithCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DockWithCube, null, options, request);
      }
      /// <summary>
      /// Tells Vector to dock with a light cube with a given approach angle and distance.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DockWithCubeResponse> DockWithCubeAsync(global::Anki.Vector.ExternalInterface.DockWithCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DockWithCubeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tells Vector to dock with a light cube with a given approach angle and distance.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DockWithCubeResponse> DockWithCubeAsync(global::Anki.Vector.ExternalInterface.DockWithCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DockWithCube, null, options, request);
      }
      /// <summary>
      /// Drive Vector off the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveOffChargerResponse DriveOffCharger(global::Anki.Vector.ExternalInterface.DriveOffChargerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveOffCharger(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Drive Vector off the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveOffChargerResponse DriveOffCharger(global::Anki.Vector.ExternalInterface.DriveOffChargerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DriveOffCharger, null, options, request);
      }
      /// <summary>
      /// Drive Vector off the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveOffChargerResponse> DriveOffChargerAsync(global::Anki.Vector.ExternalInterface.DriveOffChargerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveOffChargerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Drive Vector off the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveOffChargerResponse> DriveOffChargerAsync(global::Anki.Vector.ExternalInterface.DriveOffChargerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DriveOffCharger, null, options, request);
      }
      /// <summary>
      /// Drive Vector onto the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveOnChargerResponse DriveOnCharger(global::Anki.Vector.ExternalInterface.DriveOnChargerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveOnCharger(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Drive Vector onto the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveOnChargerResponse DriveOnCharger(global::Anki.Vector.ExternalInterface.DriveOnChargerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DriveOnCharger, null, options, request);
      }
      /// <summary>
      /// Drive Vector onto the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveOnChargerResponse> DriveOnChargerAsync(global::Anki.Vector.ExternalInterface.DriveOnChargerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveOnChargerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Drive Vector onto the charger.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveOnChargerResponse> DriveOnChargerAsync(global::Anki.Vector.ExternalInterface.DriveOnChargerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DriveOnCharger, null, options, request);
      }
      /// <summary>
      /// Make Vector look for faces by turning and angling his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.FindFacesResponse FindFaces(global::Anki.Vector.ExternalInterface.FindFacesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FindFaces(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector look for faces by turning and angling his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.FindFacesResponse FindFaces(global::Anki.Vector.ExternalInterface.FindFacesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_FindFaces, null, options, request);
      }
      /// <summary>
      /// Make Vector look for faces by turning and angling his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.FindFacesResponse> FindFacesAsync(global::Anki.Vector.ExternalInterface.FindFacesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FindFacesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector look for faces by turning and angling his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.FindFacesResponse> FindFacesAsync(global::Anki.Vector.ExternalInterface.FindFacesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_FindFaces, null, options, request);
      }
      /// <summary>
      /// Make Vector look around in place by turning and moving his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse LookAroundInPlace(global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return LookAroundInPlace(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector look around in place by turning and moving his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse LookAroundInPlace(global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_LookAroundInPlace, null, options, request);
      }
      /// <summary>
      /// Make Vector look around in place by turning and moving his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse> LookAroundInPlaceAsync(global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return LookAroundInPlaceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector look around in place by turning and moving his head
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.LookAroundInPlaceResponse> LookAroundInPlaceAsync(global::Anki.Vector.ExternalInterface.LookAroundInPlaceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_LookAroundInPlace, null, options, request);
      }
      /// <summary>
      /// Make Vector roll his block, regardless of relative position and orientation
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.RollBlockResponse RollBlock(global::Anki.Vector.ExternalInterface.RollBlockRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RollBlock(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector roll his block, regardless of relative position and orientation
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.RollBlockResponse RollBlock(global::Anki.Vector.ExternalInterface.RollBlockRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RollBlock, null, options, request);
      }
      /// <summary>
      /// Make Vector roll his block, regardless of relative position and orientation
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.RollBlockResponse> RollBlockAsync(global::Anki.Vector.ExternalInterface.RollBlockRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RollBlockAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector roll his block, regardless of relative position and orientation
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.RollBlockResponse> RollBlockAsync(global::Anki.Vector.ExternalInterface.RollBlockRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RollBlock, null, options, request);
      }
      /// <summary>
      /// Get the photos info.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PhotosInfoResponse PhotosInfo(global::Anki.Vector.ExternalInterface.PhotosInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PhotosInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get the photos info.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PhotosInfoResponse PhotosInfo(global::Anki.Vector.ExternalInterface.PhotosInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PhotosInfo, null, options, request);
      }
      /// <summary>
      /// Get the photos info.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PhotosInfoResponse> PhotosInfoAsync(global::Anki.Vector.ExternalInterface.PhotosInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PhotosInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get the photos info.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PhotosInfoResponse> PhotosInfoAsync(global::Anki.Vector.ExternalInterface.PhotosInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PhotosInfo, null, options, request);
      }
      /// <summary>
      /// Get a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PhotoResponse Photo(global::Anki.Vector.ExternalInterface.PhotoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Photo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PhotoResponse Photo(global::Anki.Vector.ExternalInterface.PhotoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Photo, null, options, request);
      }
      /// <summary>
      /// Get a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PhotoResponse> PhotoAsync(global::Anki.Vector.ExternalInterface.PhotoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PhotoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PhotoResponse> PhotoAsync(global::Anki.Vector.ExternalInterface.PhotoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Photo, null, options, request);
      }
      /// <summary>
      /// Get a thumbnail by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ThumbnailResponse Thumbnail(global::Anki.Vector.ExternalInterface.ThumbnailRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Thumbnail(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get a thumbnail by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ThumbnailResponse Thumbnail(global::Anki.Vector.ExternalInterface.ThumbnailRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Thumbnail, null, options, request);
      }
      /// <summary>
      /// Get a thumbnail by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ThumbnailResponse> ThumbnailAsync(global::Anki.Vector.ExternalInterface.ThumbnailRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ThumbnailAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get a thumbnail by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ThumbnailResponse> ThumbnailAsync(global::Anki.Vector.ExternalInterface.ThumbnailRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Thumbnail, null, options, request);
      }
      /// <summary>
      /// Delete a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DeletePhotoResponse DeletePhoto(global::Anki.Vector.ExternalInterface.DeletePhotoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeletePhoto(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Delete a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DeletePhotoResponse DeletePhoto(global::Anki.Vector.ExternalInterface.DeletePhotoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeletePhoto, null, options, request);
      }
      /// <summary>
      /// Delete a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DeletePhotoResponse> DeletePhotoAsync(global::Anki.Vector.ExternalInterface.DeletePhotoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeletePhotoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Delete a photo by ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DeletePhotoResponse> DeletePhotoAsync(global::Anki.Vector.ExternalInterface.DeletePhotoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeletePhoto, null, options, request);
      }
      /// <summary>
      /// Tells Vector to drive in a straight line.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveStraightResponse DriveStraight(global::Anki.Vector.ExternalInterface.DriveStraightRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveStraight(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tells Vector to drive in a straight line.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DriveStraightResponse DriveStraight(global::Anki.Vector.ExternalInterface.DriveStraightRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DriveStraight, null, options, request);
      }
      /// <summary>
      /// Tells Vector to drive in a straight line.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveStraightResponse> DriveStraightAsync(global::Anki.Vector.ExternalInterface.DriveStraightRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DriveStraightAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tells Vector to drive in a straight line.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DriveStraightResponse> DriveStraightAsync(global::Anki.Vector.ExternalInterface.DriveStraightRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DriveStraight, null, options, request);
      }
      /// <summary>
      /// Turn the robot around its current position.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.TurnInPlaceResponse TurnInPlace(global::Anki.Vector.ExternalInterface.TurnInPlaceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TurnInPlace(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Turn the robot around its current position.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.TurnInPlaceResponse TurnInPlace(global::Anki.Vector.ExternalInterface.TurnInPlaceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_TurnInPlace, null, options, request);
      }
      /// <summary>
      /// Turn the robot around its current position.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.TurnInPlaceResponse> TurnInPlaceAsync(global::Anki.Vector.ExternalInterface.TurnInPlaceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TurnInPlaceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Turn the robot around its current position.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.TurnInPlaceResponse> TurnInPlaceAsync(global::Anki.Vector.ExternalInterface.TurnInPlaceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_TurnInPlace, null, options, request);
      }
      /// <summary>
      /// Tell Vector's head to move to a given angle.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetHeadAngleResponse SetHeadAngle(global::Anki.Vector.ExternalInterface.SetHeadAngleRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetHeadAngle(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector's head to move to a given angle.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetHeadAngleResponse SetHeadAngle(global::Anki.Vector.ExternalInterface.SetHeadAngleRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetHeadAngle, null, options, request);
      }
      /// <summary>
      /// Tell Vector's head to move to a given angle.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetHeadAngleResponse> SetHeadAngleAsync(global::Anki.Vector.ExternalInterface.SetHeadAngleRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetHeadAngleAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector's head to move to a given angle.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetHeadAngleResponse> SetHeadAngleAsync(global::Anki.Vector.ExternalInterface.SetHeadAngleRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetHeadAngle, null, options, request);
      }
      /// <summary>
      /// Tell Vector's lift to move to a given height.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetLiftHeightResponse SetLiftHeight(global::Anki.Vector.ExternalInterface.SetLiftHeightRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetLiftHeight(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector's lift to move to a given height.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetLiftHeightResponse SetLiftHeight(global::Anki.Vector.ExternalInterface.SetLiftHeightRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetLiftHeight, null, options, request);
      }
      /// <summary>
      /// Tell Vector's lift to move to a given height.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetLiftHeightResponse> SetLiftHeightAsync(global::Anki.Vector.ExternalInterface.SetLiftHeightRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetLiftHeightAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector's lift to move to a given height.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetLiftHeightResponse> SetLiftHeightAsync(global::Anki.Vector.ExternalInterface.SetLiftHeightRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetLiftHeight, null, options, request);
      }
      /// <summary>
      /// Tell Vector to turn towards this face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse TurnTowardsFace(global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TurnTowardsFace(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to turn towards this face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse TurnTowardsFace(global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_TurnTowardsFace, null, options, request);
      }
      /// <summary>
      /// Tell Vector to turn towards this face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse> TurnTowardsFaceAsync(global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TurnTowardsFaceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to turn towards this face.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.TurnTowardsFaceResponse> TurnTowardsFaceAsync(global::Anki.Vector.ExternalInterface.TurnTowardsFaceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_TurnTowardsFace, null, options, request);
      }
      /// <summary>
      /// Tell Vector to drive to the specified object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.GoToObjectResponse GoToObject(global::Anki.Vector.ExternalInterface.GoToObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GoToObject(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to drive to the specified object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.GoToObjectResponse GoToObject(global::Anki.Vector.ExternalInterface.GoToObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GoToObject, null, options, request);
      }
      /// <summary>
      /// Tell Vector to drive to the specified object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.GoToObjectResponse> GoToObjectAsync(global::Anki.Vector.ExternalInterface.GoToObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GoToObjectAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to drive to the specified object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.GoToObjectResponse> GoToObjectAsync(global::Anki.Vector.ExternalInterface.GoToObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GoToObject, null, options, request);
      }
      /// <summary>
      /// Tell Vector to roll his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.RollObjectResponse RollObject(global::Anki.Vector.ExternalInterface.RollObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RollObject(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to roll his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.RollObjectResponse RollObject(global::Anki.Vector.ExternalInterface.RollObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RollObject, null, options, request);
      }
      /// <summary>
      /// Tell Vector to roll his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.RollObjectResponse> RollObjectAsync(global::Anki.Vector.ExternalInterface.RollObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RollObjectAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to roll his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.RollObjectResponse> RollObjectAsync(global::Anki.Vector.ExternalInterface.RollObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RollObject, null, options, request);
      }
      /// <summary>
      /// Tell Vector to "pop a wheelie" using his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PopAWheelieResponse PopAWheelie(global::Anki.Vector.ExternalInterface.PopAWheelieRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PopAWheelie(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to "pop a wheelie" using his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PopAWheelieResponse PopAWheelie(global::Anki.Vector.ExternalInterface.PopAWheelieRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PopAWheelie, null, options, request);
      }
      /// <summary>
      /// Tell Vector to "pop a wheelie" using his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PopAWheelieResponse> PopAWheelieAsync(global::Anki.Vector.ExternalInterface.PopAWheelieRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PopAWheelieAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Tell Vector to "pop a wheelie" using his cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PopAWheelieResponse> PopAWheelieAsync(global::Anki.Vector.ExternalInterface.PopAWheelieRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PopAWheelie, null, options, request);
      }
      /// <summary>
      /// Instruct the robot to pick up the supplied object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PickupObjectResponse PickupObject(global::Anki.Vector.ExternalInterface.PickupObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PickupObject(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Instruct the robot to pick up the supplied object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PickupObjectResponse PickupObject(global::Anki.Vector.ExternalInterface.PickupObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PickupObject, null, options, request);
      }
      /// <summary>
      /// Instruct the robot to pick up the supplied object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PickupObjectResponse> PickupObjectAsync(global::Anki.Vector.ExternalInterface.PickupObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PickupObjectAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Instruct the robot to pick up the supplied object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PickupObjectResponse> PickupObjectAsync(global::Anki.Vector.ExternalInterface.PickupObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PickupObject, null, options, request);
      }
      /// <summary>
      /// Ask Vector to place the object he is carrying on the ground at the current location.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse PlaceObjectOnGroundHere(global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PlaceObjectOnGroundHere(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Ask Vector to place the object he is carrying on the ground at the current location.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse PlaceObjectOnGroundHere(global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PlaceObjectOnGroundHere, null, options, request);
      }
      /// <summary>
      /// Ask Vector to place the object he is carrying on the ground at the current location.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse> PlaceObjectOnGroundHereAsync(global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PlaceObjectOnGroundHereAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Ask Vector to place the object he is carrying on the ground at the current location.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereResponse> PlaceObjectOnGroundHereAsync(global::Anki.Vector.ExternalInterface.PlaceObjectOnGroundHereRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PlaceObjectOnGroundHere, null, options, request);
      }
      /// <summary>
      /// Set the Robot's master volume
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.MasterVolumeResponse SetMasterVolume(global::Anki.Vector.ExternalInterface.MasterVolumeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetMasterVolume(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set the Robot's master volume
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.MasterVolumeResponse SetMasterVolume(global::Anki.Vector.ExternalInterface.MasterVolumeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetMasterVolume, null, options, request);
      }
      /// <summary>
      /// Set the Robot's master volume
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.MasterVolumeResponse> SetMasterVolumeAsync(global::Anki.Vector.ExternalInterface.MasterVolumeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetMasterVolumeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set the Robot's master volume
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.MasterVolumeResponse> SetMasterVolumeAsync(global::Anki.Vector.ExternalInterface.MasterVolumeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetMasterVolume, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.UserAuthenticationResponse UserAuthentication(global::Anki.Vector.ExternalInterface.UserAuthenticationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UserAuthentication(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.UserAuthenticationResponse UserAuthentication(global::Anki.Vector.ExternalInterface.UserAuthenticationRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_UserAuthentication, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.UserAuthenticationResponse> UserAuthenticationAsync(global::Anki.Vector.ExternalInterface.UserAuthenticationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UserAuthenticationAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.UserAuthenticationResponse> UserAuthenticationAsync(global::Anki.Vector.ExternalInterface.UserAuthenticationRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_UserAuthentication, null, options, request);
      }
      /// <summary>
      /// Check the current state of the battery.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.BatteryStateResponse BatteryState(global::Anki.Vector.ExternalInterface.BatteryStateRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return BatteryState(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Check the current state of the battery.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.BatteryStateResponse BatteryState(global::Anki.Vector.ExternalInterface.BatteryStateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_BatteryState, null, options, request);
      }
      /// <summary>
      /// Check the current state of the battery.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.BatteryStateResponse> BatteryStateAsync(global::Anki.Vector.ExternalInterface.BatteryStateRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return BatteryStateAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Check the current state of the battery.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.BatteryStateResponse> BatteryStateAsync(global::Anki.Vector.ExternalInterface.BatteryStateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_BatteryState, null, options, request);
      }
      /// <summary>
      /// Get the versioning information for Vector.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.VersionStateResponse VersionState(global::Anki.Vector.ExternalInterface.VersionStateRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return VersionState(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get the versioning information for Vector.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.VersionStateResponse VersionState(global::Anki.Vector.ExternalInterface.VersionStateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_VersionState, null, options, request);
      }
      /// <summary>
      /// Get the versioning information for Vector.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.VersionStateResponse> VersionStateAsync(global::Anki.Vector.ExternalInterface.VersionStateRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return VersionStateAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Get the versioning information for Vector.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.VersionStateResponse> VersionStateAsync(global::Anki.Vector.ExternalInterface.VersionStateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_VersionState, null, options, request);
      }
      /// <summary>
      /// Make Vector speak text.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SayTextResponse SayText(global::Anki.Vector.ExternalInterface.SayTextRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SayText(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector speak text.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SayTextResponse SayText(global::Anki.Vector.ExternalInterface.SayTextRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SayText, null, options, request);
      }
      /// <summary>
      /// Make Vector speak text.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SayTextResponse> SayTextAsync(global::Anki.Vector.ExternalInterface.SayTextRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SayTextAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Make Vector speak text.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SayTextResponse> SayTextAsync(global::Anki.Vector.ExternalInterface.SayTextRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SayText, null, options, request);
      }
      /// <summary>
      /// Attempt to connect to a cube. If a cube is currently connected,
      /// this will do nothing.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ConnectCubeResponse ConnectCube(global::Anki.Vector.ExternalInterface.ConnectCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ConnectCube(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Attempt to connect to a cube. If a cube is currently connected,
      /// this will do nothing.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ConnectCubeResponse ConnectCube(global::Anki.Vector.ExternalInterface.ConnectCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ConnectCube, null, options, request);
      }
      /// <summary>
      /// Attempt to connect to a cube. If a cube is currently connected,
      /// this will do nothing.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ConnectCubeResponse> ConnectCubeAsync(global::Anki.Vector.ExternalInterface.ConnectCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ConnectCubeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Attempt to connect to a cube. If a cube is currently connected,
      /// this will do nothing.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ConnectCubeResponse> ConnectCubeAsync(global::Anki.Vector.ExternalInterface.ConnectCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ConnectCube, null, options, request);
      }
      /// <summary>
      /// Requests a disconnection from the currently connected cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DisconnectCubeResponse DisconnectCube(global::Anki.Vector.ExternalInterface.DisconnectCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DisconnectCube(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Requests a disconnection from the currently connected cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DisconnectCubeResponse DisconnectCube(global::Anki.Vector.ExternalInterface.DisconnectCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DisconnectCube, null, options, request);
      }
      /// <summary>
      /// Requests a disconnection from the currently connected cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DisconnectCubeResponse> DisconnectCubeAsync(global::Anki.Vector.ExternalInterface.DisconnectCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DisconnectCubeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Requests a disconnection from the currently connected cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DisconnectCubeResponse> DisconnectCubeAsync(global::Anki.Vector.ExternalInterface.DisconnectCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DisconnectCube, null, options, request);
      }
      public virtual global::Anki.Vector.ExternalInterface.CubesAvailableResponse CubesAvailable(global::Anki.Vector.ExternalInterface.CubesAvailableRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CubesAvailable(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::Anki.Vector.ExternalInterface.CubesAvailableResponse CubesAvailable(global::Anki.Vector.ExternalInterface.CubesAvailableRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CubesAvailable, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CubesAvailableResponse> CubesAvailableAsync(global::Anki.Vector.ExternalInterface.CubesAvailableRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CubesAvailableAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CubesAvailableResponse> CubesAvailableAsync(global::Anki.Vector.ExternalInterface.CubesAvailableRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CubesAvailable, null, options, request);
      }
      /// <summary>
      /// Signal a connected cube to flash its lights using the default cube
      /// flash animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse FlashCubeLights(global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FlashCubeLights(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Signal a connected cube to flash its lights using the default cube
      /// flash animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse FlashCubeLights(global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_FlashCubeLights, null, options, request);
      }
      /// <summary>
      /// Signal a connected cube to flash its lights using the default cube
      /// flash animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse> FlashCubeLightsAsync(global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FlashCubeLightsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Signal a connected cube to flash its lights using the default cube
      /// flash animation.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.FlashCubeLightsResponse> FlashCubeLightsAsync(global::Anki.Vector.ExternalInterface.FlashCubeLightsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_FlashCubeLights, null, options, request);
      }
      /// <summary>
      /// Forget the robot's preferred cube. This will cause the robot to
      /// connect to the cube with the highest RSSI (signal strength) next
      /// time a connection is requested. Saves this preference to disk.
      /// The next cube that the robot connects to will become its
      /// preferred cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse ForgetPreferredCube(global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ForgetPreferredCube(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Forget the robot's preferred cube. This will cause the robot to
      /// connect to the cube with the highest RSSI (signal strength) next
      /// time a connection is requested. Saves this preference to disk.
      /// The next cube that the robot connects to will become its
      /// preferred cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse ForgetPreferredCube(global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ForgetPreferredCube, null, options, request);
      }
      /// <summary>
      /// Forget the robot's preferred cube. This will cause the robot to
      /// connect to the cube with the highest RSSI (signal strength) next
      /// time a connection is requested. Saves this preference to disk.
      /// The next cube that the robot connects to will become its
      /// preferred cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse> ForgetPreferredCubeAsync(global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ForgetPreferredCubeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Forget the robot's preferred cube. This will cause the robot to
      /// connect to the cube with the highest RSSI (signal strength) next
      /// time a connection is requested. Saves this preference to disk.
      /// The next cube that the robot connects to will become its
      /// preferred cube.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.ForgetPreferredCubeResponse> ForgetPreferredCubeAsync(global::Anki.Vector.ExternalInterface.ForgetPreferredCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ForgetPreferredCube, null, options, request);
      }
      /// <summary>
      /// Set the robot's preferred cube and save it to disk. The robot
      /// will always attempt to connect to this cube if it is available.
      /// This is only used in simulation for now.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse SetPreferredCube(global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetPreferredCube(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set the robot's preferred cube and save it to disk. The robot
      /// will always attempt to connect to this cube if it is available.
      /// This is only used in simulation for now.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse SetPreferredCube(global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetPreferredCube, null, options, request);
      }
      /// <summary>
      /// Set the robot's preferred cube and save it to disk. The robot
      /// will always attempt to connect to this cube if it is available.
      /// This is only used in simulation for now.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse> SetPreferredCubeAsync(global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetPreferredCubeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set the robot's preferred cube and save it to disk. The robot
      /// will always attempt to connect to this cube if it is available.
      /// This is only used in simulation for now.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetPreferredCubeResponse> SetPreferredCubeAsync(global::Anki.Vector.ExternalInterface.SetPreferredCubeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetPreferredCube, null, options, request);
      }
      /// <summary>
      /// Causes the robot to forget about custom objects it currently knows about.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse DeleteCustomObjects(global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteCustomObjects(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Causes the robot to forget about custom objects it currently knows about.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse DeleteCustomObjects(global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeleteCustomObjects, null, options, request);
      }
      /// <summary>
      /// Causes the robot to forget about custom objects it currently knows about.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse> DeleteCustomObjectsAsync(global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteCustomObjectsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Causes the robot to forget about custom objects it currently knows about.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DeleteCustomObjectsResponse> DeleteCustomObjectsAsync(global::Anki.Vector.ExternalInterface.DeleteCustomObjectsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeleteCustomObjects, null, options, request);
      }
      /// <summary>
      /// Creates a permanent custom object instance in the robot's world, with no connection to the vision system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse CreateFixedCustomObject(global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateFixedCustomObject(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Creates a permanent custom object instance in the robot's world, with no connection to the vision system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse CreateFixedCustomObject(global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateFixedCustomObject, null, options, request);
      }
      /// <summary>
      /// Creates a permanent custom object instance in the robot's world, with no connection to the vision system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse> CreateFixedCustomObjectAsync(global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateFixedCustomObjectAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Creates a permanent custom object instance in the robot's world, with no connection to the vision system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectResponse> CreateFixedCustomObjectAsync(global::Anki.Vector.ExternalInterface.CreateFixedCustomObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateFixedCustomObject, null, options, request);
      }
      /// <summary>
      /// Creates a custom object with distinct custom marker(s).
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse DefineCustomObject(global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DefineCustomObject(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Creates a custom object with distinct custom marker(s).
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse DefineCustomObject(global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DefineCustomObject, null, options, request);
      }
      /// <summary>
      /// Creates a custom object with distinct custom marker(s).
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse> DefineCustomObjectAsync(global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DefineCustomObjectAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Creates a custom object with distinct custom marker(s).
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.DefineCustomObjectResponse> DefineCustomObjectAsync(global::Anki.Vector.ExternalInterface.DefineCustomObjectRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DefineCustomObject, null, options, request);
      }
      /// <summary>
      /// Set each of the lights on the currently connected cube based on two
      /// rgb values each and timing data for how to transition between them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetCubeLightsResponse SetCubeLights(global::Anki.Vector.ExternalInterface.SetCubeLightsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetCubeLights(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set each of the lights on the currently connected cube based on two
      /// rgb values each and timing data for how to transition between them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetCubeLightsResponse SetCubeLights(global::Anki.Vector.ExternalInterface.SetCubeLightsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetCubeLights, null, options, request);
      }
      /// <summary>
      /// Set each of the lights on the currently connected cube based on two
      /// rgb values each and timing data for how to transition between them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetCubeLightsResponse> SetCubeLightsAsync(global::Anki.Vector.ExternalInterface.SetCubeLightsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetCubeLightsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set each of the lights on the currently connected cube based on two
      /// rgb values each and timing data for how to transition between them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetCubeLightsResponse> SetCubeLightsAsync(global::Anki.Vector.ExternalInterface.SetCubeLightsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetCubeLights, null, options, request);
      }
      /// <summary>
      /// Request an audio feed from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.AudioFeedResponse> AudioFeed(global::Anki.Vector.ExternalInterface.AudioFeedRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AudioFeed(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Request an audio feed from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.AudioFeedResponse> AudioFeed(global::Anki.Vector.ExternalInterface.AudioFeedRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_AudioFeed, null, options, request);
      }
      /// <summary>
      /// Request a camera feed from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.CameraFeedResponse> CameraFeed(global::Anki.Vector.ExternalInterface.CameraFeedRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CameraFeed(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Request a camera feed from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.CameraFeedResponse> CameraFeed(global::Anki.Vector.ExternalInterface.CameraFeedRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_CameraFeed, null, options, request);
      }
      /// <summary>
      /// Request a single image to be captured and sent from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse CaptureSingleImage(global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CaptureSingleImage(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Request a single image to be captured and sent from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse CaptureSingleImage(global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CaptureSingleImage, null, options, request);
      }
      /// <summary>
      /// Request a single image to be captured and sent from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse> CaptureSingleImageAsync(global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CaptureSingleImageAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Request a single image to be captured and sent from the robot.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.CaptureSingleImageResponse> CaptureSingleImageAsync(global::Anki.Vector.ExternalInterface.CaptureSingleImageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CaptureSingleImage, null, options, request);
      }
      /// <summary>
      /// Set Vector's eye color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetEyeColorResponse SetEyeColor(global::Anki.Vector.ExternalInterface.SetEyeColorRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetEyeColor(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set Vector's eye color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Anki.Vector.ExternalInterface.SetEyeColorResponse SetEyeColor(global::Anki.Vector.ExternalInterface.SetEyeColorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetEyeColor, null, options, request);
      }
      /// <summary>
      /// Set Vector's eye color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetEyeColorResponse> SetEyeColorAsync(global::Anki.Vector.ExternalInterface.SetEyeColorRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetEyeColorAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Set Vector's eye color.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Anki.Vector.ExternalInterface.SetEyeColorResponse> SetEyeColorAsync(global::Anki.Vector.ExternalInterface.SetEyeColorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetEyeColor, null, options, request);
      }
      /// <summary>
      /// Stream navigation map data.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.NavMapFeedResponse> NavMapFeed(global::Anki.Vector.ExternalInterface.NavMapFeedRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return NavMapFeed(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Stream navigation map data.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Anki.Vector.ExternalInterface.NavMapFeedResponse> NavMapFeed(global::Anki.Vector.ExternalInterface.NavMapFeedRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_NavMapFeed, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override ExternalInterfaceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new ExternalInterfaceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(ExternalInterfaceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_ProtocolVersion, serviceImpl.ProtocolVersion)
          .AddMethod(__Method_SDKInitialization, serviceImpl.SDKInitialization)
          .AddMethod(__Method_DriveWheels, serviceImpl.DriveWheels)
          .AddMethod(__Method_PlayAnimationTrigger, serviceImpl.PlayAnimationTrigger)
          .AddMethod(__Method_PlayAnimation, serviceImpl.PlayAnimation)
          .AddMethod(__Method_ListAnimations, serviceImpl.ListAnimations)
          .AddMethod(__Method_ListAnimationTriggers, serviceImpl.ListAnimationTriggers)
          .AddMethod(__Method_MoveHead, serviceImpl.MoveHead)
          .AddMethod(__Method_MoveLift, serviceImpl.MoveLift)
          .AddMethod(__Method_StopAllMotors, serviceImpl.StopAllMotors)
          .AddMethod(__Method_DisplayFaceImageRGB, serviceImpl.DisplayFaceImageRGB)
          .AddMethod(__Method_EventStream, serviceImpl.EventStream)
          .AddMethod(__Method_ExternalAudioStreamPlayback, serviceImpl.ExternalAudioStreamPlayback)
          .AddMethod(__Method_BehaviorControl, serviceImpl.BehaviorControl)
          .AddMethod(__Method_AssumeBehaviorControl, serviceImpl.AssumeBehaviorControl)
          .AddMethod(__Method_CancelFaceEnrollment, serviceImpl.CancelFaceEnrollment)
          .AddMethod(__Method_RequestEnrolledNames, serviceImpl.RequestEnrolledNames)
          .AddMethod(__Method_UpdateEnrolledFaceByID, serviceImpl.UpdateEnrolledFaceByID)
          .AddMethod(__Method_EraseEnrolledFaceByID, serviceImpl.EraseEnrolledFaceByID)
          .AddMethod(__Method_EraseAllEnrolledFaces, serviceImpl.EraseAllEnrolledFaces)
          .AddMethod(__Method_SetFaceToEnroll, serviceImpl.SetFaceToEnroll)
          .AddMethod(__Method_EnableMarkerDetection, serviceImpl.EnableMarkerDetection)
          .AddMethod(__Method_EnableFaceDetection, serviceImpl.EnableFaceDetection)
          .AddMethod(__Method_EnableMotionDetection, serviceImpl.EnableMotionDetection)
          .AddMethod(__Method_EnableMirrorMode, serviceImpl.EnableMirrorMode)
          .AddMethod(__Method_EnableImageStreaming, serviceImpl.EnableImageStreaming)
          .AddMethod(__Method_IsImageStreamingEnabled, serviceImpl.IsImageStreamingEnabled)
          .AddMethod(__Method_CancelActionByIdTag, serviceImpl.CancelActionByIdTag)
          .AddMethod(__Method_GoToPose, serviceImpl.GoToPose)
          .AddMethod(__Method_DockWithCube, serviceImpl.DockWithCube)
          .AddMethod(__Method_DriveOffCharger, serviceImpl.DriveOffCharger)
          .AddMethod(__Method_DriveOnCharger, serviceImpl.DriveOnCharger)
          .AddMethod(__Method_FindFaces, serviceImpl.FindFaces)
          .AddMethod(__Method_LookAroundInPlace, serviceImpl.LookAroundInPlace)
          .AddMethod(__Method_RollBlock, serviceImpl.RollBlock)
          .AddMethod(__Method_PhotosInfo, serviceImpl.PhotosInfo)
          .AddMethod(__Method_Photo, serviceImpl.Photo)
          .AddMethod(__Method_Thumbnail, serviceImpl.Thumbnail)
          .AddMethod(__Method_DeletePhoto, serviceImpl.DeletePhoto)
          .AddMethod(__Method_DriveStraight, serviceImpl.DriveStraight)
          .AddMethod(__Method_TurnInPlace, serviceImpl.TurnInPlace)
          .AddMethod(__Method_SetHeadAngle, serviceImpl.SetHeadAngle)
          .AddMethod(__Method_SetLiftHeight, serviceImpl.SetLiftHeight)
          .AddMethod(__Method_TurnTowardsFace, serviceImpl.TurnTowardsFace)
          .AddMethod(__Method_GoToObject, serviceImpl.GoToObject)
          .AddMethod(__Method_RollObject, serviceImpl.RollObject)
          .AddMethod(__Method_PopAWheelie, serviceImpl.PopAWheelie)
          .AddMethod(__Method_PickupObject, serviceImpl.PickupObject)
          .AddMethod(__Method_PlaceObjectOnGroundHere, serviceImpl.PlaceObjectOnGroundHere)
          .AddMethod(__Method_SetMasterVolume, serviceImpl.SetMasterVolume)
          .AddMethod(__Method_UserAuthentication, serviceImpl.UserAuthentication)
          .AddMethod(__Method_BatteryState, serviceImpl.BatteryState)
          .AddMethod(__Method_VersionState, serviceImpl.VersionState)
          .AddMethod(__Method_SayText, serviceImpl.SayText)
          .AddMethod(__Method_ConnectCube, serviceImpl.ConnectCube)
          .AddMethod(__Method_DisconnectCube, serviceImpl.DisconnectCube)
          .AddMethod(__Method_CubesAvailable, serviceImpl.CubesAvailable)
          .AddMethod(__Method_FlashCubeLights, serviceImpl.FlashCubeLights)
          .AddMethod(__Method_ForgetPreferredCube, serviceImpl.ForgetPreferredCube)
          .AddMethod(__Method_SetPreferredCube, serviceImpl.SetPreferredCube)
          .AddMethod(__Method_DeleteCustomObjects, serviceImpl.DeleteCustomObjects)
          .AddMethod(__Method_CreateFixedCustomObject, serviceImpl.CreateFixedCustomObject)
          .AddMethod(__Method_DefineCustomObject, serviceImpl.DefineCustomObject)
          .AddMethod(__Method_SetCubeLights, serviceImpl.SetCubeLights)
          .AddMethod(__Method_AudioFeed, serviceImpl.AudioFeed)
          .AddMethod(__Method_CameraFeed, serviceImpl.CameraFeed)
          .AddMethod(__Method_CaptureSingleImage, serviceImpl.CaptureSingleImage)
          .AddMethod(__Method_SetEyeColor, serviceImpl.SetEyeColor)
          .AddMethod(__Method_NavMapFeed, serviceImpl.NavMapFeed).Build();
    }

    /// <summary>Register service method implementations with a service binder. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, ExternalInterfaceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_ProtocolVersion, serviceImpl.ProtocolVersion);
      serviceBinder.AddMethod(__Method_SDKInitialization, serviceImpl.SDKInitialization);
      serviceBinder.AddMethod(__Method_DriveWheels, serviceImpl.DriveWheels);
      serviceBinder.AddMethod(__Method_PlayAnimationTrigger, serviceImpl.PlayAnimationTrigger);
      serviceBinder.AddMethod(__Method_PlayAnimation, serviceImpl.PlayAnimation);
      serviceBinder.AddMethod(__Method_ListAnimations, serviceImpl.ListAnimations);
      serviceBinder.AddMethod(__Method_ListAnimationTriggers, serviceImpl.ListAnimationTriggers);
      serviceBinder.AddMethod(__Method_MoveHead, serviceImpl.MoveHead);
      serviceBinder.AddMethod(__Method_MoveLift, serviceImpl.MoveLift);
      serviceBinder.AddMethod(__Method_StopAllMotors, serviceImpl.StopAllMotors);
      serviceBinder.AddMethod(__Method_DisplayFaceImageRGB, serviceImpl.DisplayFaceImageRGB);
      serviceBinder.AddMethod(__Method_EventStream, serviceImpl.EventStream);
      serviceBinder.AddMethod(__Method_ExternalAudioStreamPlayback, serviceImpl.ExternalAudioStreamPlayback);
      serviceBinder.AddMethod(__Method_BehaviorControl, serviceImpl.BehaviorControl);
      serviceBinder.AddMethod(__Method_AssumeBehaviorControl, serviceImpl.AssumeBehaviorControl);
      serviceBinder.AddMethod(__Method_CancelFaceEnrollment, serviceImpl.CancelFaceEnrollment);
      serviceBinder.AddMethod(__Method_RequestEnrolledNames, serviceImpl.RequestEnrolledNames);
      serviceBinder.AddMethod(__Method_UpdateEnrolledFaceByID, serviceImpl.UpdateEnrolledFaceByID);
      serviceBinder.AddMethod(__Method_EraseEnrolledFaceByID, serviceImpl.EraseEnrolledFaceByID);
      serviceBinder.AddMethod(__Method_EraseAllEnrolledFaces, serviceImpl.EraseAllEnrolledFaces);
      serviceBinder.AddMethod(__Method_SetFaceToEnroll, serviceImpl.SetFaceToEnroll);
      serviceBinder.AddMethod(__Method_EnableMarkerDetection, serviceImpl.EnableMarkerDetection);
      serviceBinder.AddMethod(__Method_EnableFaceDetection, serviceImpl.EnableFaceDetection);
      serviceBinder.AddMethod(__Method_EnableMotionDetection, serviceImpl.EnableMotionDetection);
      serviceBinder.AddMethod(__Method_EnableMirrorMode, serviceImpl.EnableMirrorMode);
      serviceBinder.AddMethod(__Method_EnableImageStreaming, serviceImpl.EnableImageStreaming);
      serviceBinder.AddMethod(__Method_IsImageStreamingEnabled, serviceImpl.IsImageStreamingEnabled);
      serviceBinder.AddMethod(__Method_CancelActionByIdTag, serviceImpl.CancelActionByIdTag);
      serviceBinder.AddMethod(__Method_GoToPose, serviceImpl.GoToPose);
      serviceBinder.AddMethod(__Method_DockWithCube, serviceImpl.DockWithCube);
      serviceBinder.AddMethod(__Method_DriveOffCharger, serviceImpl.DriveOffCharger);
      serviceBinder.AddMethod(__Method_DriveOnCharger, serviceImpl.DriveOnCharger);
      serviceBinder.AddMethod(__Method_FindFaces, serviceImpl.FindFaces);
      serviceBinder.AddMethod(__Method_LookAroundInPlace, serviceImpl.LookAroundInPlace);
      serviceBinder.AddMethod(__Method_RollBlock, serviceImpl.RollBlock);
      serviceBinder.AddMethod(__Method_PhotosInfo, serviceImpl.PhotosInfo);
      serviceBinder.AddMethod(__Method_Photo, serviceImpl.Photo);
      serviceBinder.AddMethod(__Method_Thumbnail, serviceImpl.Thumbnail);
      serviceBinder.AddMethod(__Method_DeletePhoto, serviceImpl.DeletePhoto);
      serviceBinder.AddMethod(__Method_DriveStraight, serviceImpl.DriveStraight);
      serviceBinder.AddMethod(__Method_TurnInPlace, serviceImpl.TurnInPlace);
      serviceBinder.AddMethod(__Method_SetHeadAngle, serviceImpl.SetHeadAngle);
      serviceBinder.AddMethod(__Method_SetLiftHeight, serviceImpl.SetLiftHeight);
      serviceBinder.AddMethod(__Method_TurnTowardsFace, serviceImpl.TurnTowardsFace);
      serviceBinder.AddMethod(__Method_GoToObject, serviceImpl.GoToObject);
      serviceBinder.AddMethod(__Method_RollObject, serviceImpl.RollObject);
      serviceBinder.AddMethod(__Method_PopAWheelie, serviceImpl.PopAWheelie);
      serviceBinder.AddMethod(__Method_PickupObject, serviceImpl.PickupObject);
      serviceBinder.AddMethod(__Method_PlaceObjectOnGroundHere, serviceImpl.PlaceObjectOnGroundHere);
      serviceBinder.AddMethod(__Method_SetMasterVolume, serviceImpl.SetMasterVolume);
      serviceBinder.AddMethod(__Method_UserAuthentication, serviceImpl.UserAuthentication);
      serviceBinder.AddMethod(__Method_BatteryState, serviceImpl.BatteryState);
      serviceBinder.AddMethod(__Method_VersionState, serviceImpl.VersionState);
      serviceBinder.AddMethod(__Method_SayText, serviceImpl.SayText);
      serviceBinder.AddMethod(__Method_ConnectCube, serviceImpl.ConnectCube);
      serviceBinder.AddMethod(__Method_DisconnectCube, serviceImpl.DisconnectCube);
      serviceBinder.AddMethod(__Method_CubesAvailable, serviceImpl.CubesAvailable);
      serviceBinder.AddMethod(__Method_FlashCubeLights, serviceImpl.FlashCubeLights);
      serviceBinder.AddMethod(__Method_ForgetPreferredCube, serviceImpl.ForgetPreferredCube);
      serviceBinder.AddMethod(__Method_SetPreferredCube, serviceImpl.SetPreferredCube);
      serviceBinder.AddMethod(__Method_DeleteCustomObjects, serviceImpl.DeleteCustomObjects);
      serviceBinder.AddMethod(__Method_CreateFixedCustomObject, serviceImpl.CreateFixedCustomObject);
      serviceBinder.AddMethod(__Method_DefineCustomObject, serviceImpl.DefineCustomObject);
      serviceBinder.AddMethod(__Method_SetCubeLights, serviceImpl.SetCubeLights);
      serviceBinder.AddMethod(__Method_AudioFeed, serviceImpl.AudioFeed);
      serviceBinder.AddMethod(__Method_CameraFeed, serviceImpl.CameraFeed);
      serviceBinder.AddMethod(__Method_CaptureSingleImage, serviceImpl.CaptureSingleImage);
      serviceBinder.AddMethod(__Method_SetEyeColor, serviceImpl.SetEyeColor);
      serviceBinder.AddMethod(__Method_NavMapFeed, serviceImpl.NavMapFeed);
    }

  }
}
#endregion
